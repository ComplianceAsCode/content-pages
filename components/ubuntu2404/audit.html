<!DOCTYPE html>
<html lang="en">
<head>
  
  <meta charset="UTF-8"/>
  <title>Rules Related To 'audit'</title>
  
<style>
</style>
</head>
<body>



<h1>Rules Related To 'audit'</h1>





<h2>Component overview</h2>

<h3>Relevant packages:</h3>

<ul>

<li>audispd-plugins</li>

<li>audit</li>

<li>audit-audispd-plugins</li>

<li>audit-libs</li>

</ul>


<h3>Relevant groups:</h3>

<ul>

<li>audit_dac_actions</li>

<li>audit_execution_acl_commands</li>

<li>audit_execution_selinux_commands</li>

<li>audit_file_deletion_events</li>

<li>audit_file_modification</li>

<li>audit_kernel_module_loading</li>

<li>audit_login_events</li>

<li>audit_privileged_commands</li>

<li>audit_time_rules</li>

<li>auditd_configure_rules</li>

<li>auditing</li>

<li>configure_auditd_data_retention</li>

</ul>


<h3>Changelog:</h3>

<div>No changes recorded.</div>


<h3>Relevant rules:</h3>

<ul>

<li><a href="#audit_access_failed">audit_access_failed</a></li>

<li><a href="#audit_access_failed_aarch64">audit_access_failed_aarch64</a></li>

<li><a href="#audit_access_failed_ppc64le">audit_access_failed_ppc64le</a></li>

<li><a href="#audit_access_success">audit_access_success</a></li>

<li><a href="#audit_access_success_aarch64">audit_access_success_aarch64</a></li>

<li><a href="#audit_access_success_ppc64le">audit_access_success_ppc64le</a></li>

<li><a href="#audit_basic_configuration">audit_basic_configuration</a></li>

<li><a href="#audit_create_failed">audit_create_failed</a></li>

<li><a href="#audit_create_failed_aarch64">audit_create_failed_aarch64</a></li>

<li><a href="#audit_create_failed_ppc64le">audit_create_failed_ppc64le</a></li>

<li><a href="#audit_create_success">audit_create_success</a></li>

<li><a href="#audit_create_success_aarch64">audit_create_success_aarch64</a></li>

<li><a href="#audit_create_success_ppc64le">audit_create_success_ppc64le</a></li>

<li><a href="#audit_delete_failed">audit_delete_failed</a></li>

<li><a href="#audit_delete_failed_aarch64">audit_delete_failed_aarch64</a></li>

<li><a href="#audit_delete_failed_ppc64le">audit_delete_failed_ppc64le</a></li>

<li><a href="#audit_delete_success">audit_delete_success</a></li>

<li><a href="#audit_delete_success_aarch64">audit_delete_success_aarch64</a></li>

<li><a href="#audit_delete_success_ppc64le">audit_delete_success_ppc64le</a></li>

<li><a href="#audit_immutable_login_uids">audit_immutable_login_uids</a></li>

<li><a href="#audit_modify_failed">audit_modify_failed</a></li>

<li><a href="#audit_modify_failed_aarch64">audit_modify_failed_aarch64</a></li>

<li><a href="#audit_modify_failed_ppc64le">audit_modify_failed_ppc64le</a></li>

<li><a href="#audit_modify_success">audit_modify_success</a></li>

<li><a href="#audit_modify_success_aarch64">audit_modify_success_aarch64</a></li>

<li><a href="#audit_modify_success_ppc64le">audit_modify_success_ppc64le</a></li>

<li><a href="#audit_module_load">audit_module_load</a></li>

<li><a href="#audit_module_load_ppc64le">audit_module_load_ppc64le</a></li>

<li><a href="#audit_ospp_general">audit_ospp_general</a></li>

<li><a href="#audit_ospp_general_aarch64">audit_ospp_general_aarch64</a></li>

<li><a href="#audit_ospp_general_ppc64le">audit_ospp_general_ppc64le</a></li>

<li><a href="#audit_owner_change_failed">audit_owner_change_failed</a></li>

<li><a href="#audit_owner_change_failed_aarch64">audit_owner_change_failed_aarch64</a></li>

<li><a href="#audit_owner_change_failed_ppc64le">audit_owner_change_failed_ppc64le</a></li>

<li><a href="#audit_owner_change_success">audit_owner_change_success</a></li>

<li><a href="#audit_owner_change_success_aarch64">audit_owner_change_success_aarch64</a></li>

<li><a href="#audit_owner_change_success_ppc64le">audit_owner_change_success_ppc64le</a></li>

<li><a href="#audit_perm_change_failed">audit_perm_change_failed</a></li>

<li><a href="#audit_perm_change_failed_aarch64">audit_perm_change_failed_aarch64</a></li>

<li><a href="#audit_perm_change_failed_ppc64le">audit_perm_change_failed_ppc64le</a></li>

<li><a href="#audit_perm_change_success">audit_perm_change_success</a></li>

<li><a href="#audit_perm_change_success_aarch64">audit_perm_change_success_aarch64</a></li>

<li><a href="#audit_perm_change_success_ppc64le">audit_perm_change_success_ppc64le</a></li>

<li><a href="#audit_privileged_commands_init">audit_privileged_commands_init</a></li>

<li><a href="#audit_privileged_commands_poweroff">audit_privileged_commands_poweroff</a></li>

<li><a href="#audit_privileged_commands_reboot">audit_privileged_commands_reboot</a></li>

<li><a href="#audit_privileged_commands_shutdown">audit_privileged_commands_shutdown</a></li>

<li><a href="#audit_rules_dac_modification_chmod">audit_rules_dac_modification_chmod</a></li>

<li><a href="#audit_rules_dac_modification_chown">audit_rules_dac_modification_chown</a></li>

<li><a href="#audit_rules_dac_modification_fchmod">audit_rules_dac_modification_fchmod</a></li>

<li><a href="#audit_rules_dac_modification_fchmodat">audit_rules_dac_modification_fchmodat</a></li>

<li><a href="#audit_rules_dac_modification_fchmodat2">audit_rules_dac_modification_fchmodat2</a></li>

<li><a href="#audit_rules_dac_modification_fchown">audit_rules_dac_modification_fchown</a></li>

<li><a href="#audit_rules_dac_modification_fchownat">audit_rules_dac_modification_fchownat</a></li>

<li><a href="#audit_rules_dac_modification_fremovexattr">audit_rules_dac_modification_fremovexattr</a></li>

<li><a href="#audit_rules_dac_modification_fsetxattr">audit_rules_dac_modification_fsetxattr</a></li>

<li><a href="#audit_rules_dac_modification_lchown">audit_rules_dac_modification_lchown</a></li>

<li><a href="#audit_rules_dac_modification_lremovexattr">audit_rules_dac_modification_lremovexattr</a></li>

<li><a href="#audit_rules_dac_modification_lsetxattr">audit_rules_dac_modification_lsetxattr</a></li>

<li><a href="#audit_rules_dac_modification_removexattr">audit_rules_dac_modification_removexattr</a></li>

<li><a href="#audit_rules_dac_modification_setxattr">audit_rules_dac_modification_setxattr</a></li>

<li><a href="#audit_rules_dac_modification_umount">audit_rules_dac_modification_umount</a></li>

<li><a href="#audit_rules_dac_modification_umount2">audit_rules_dac_modification_umount2</a></li>

<li><a href="#audit_rules_enable_syscall_auditing">audit_rules_enable_syscall_auditing</a></li>

<li><a href="#audit_rules_etc_group_open">audit_rules_etc_group_open</a></li>

<li><a href="#audit_rules_etc_group_open_by_handle_at">audit_rules_etc_group_open_by_handle_at</a></li>

<li><a href="#audit_rules_etc_group_openat">audit_rules_etc_group_openat</a></li>

<li><a href="#audit_rules_etc_gshadow_open">audit_rules_etc_gshadow_open</a></li>

<li><a href="#audit_rules_etc_gshadow_open_by_handle_at">audit_rules_etc_gshadow_open_by_handle_at</a></li>

<li><a href="#audit_rules_etc_gshadow_openat">audit_rules_etc_gshadow_openat</a></li>

<li><a href="#audit_rules_etc_passwd_open">audit_rules_etc_passwd_open</a></li>

<li><a href="#audit_rules_etc_passwd_open_by_handle_at">audit_rules_etc_passwd_open_by_handle_at</a></li>

<li><a href="#audit_rules_etc_passwd_openat">audit_rules_etc_passwd_openat</a></li>

<li><a href="#audit_rules_etc_shadow_open">audit_rules_etc_shadow_open</a></li>

<li><a href="#audit_rules_etc_shadow_open_by_handle_at">audit_rules_etc_shadow_open_by_handle_at</a></li>

<li><a href="#audit_rules_etc_shadow_openat">audit_rules_etc_shadow_openat</a></li>

<li><a href="#audit_rules_execution_chacl">audit_rules_execution_chacl</a></li>

<li><a href="#audit_rules_execution_chcon">audit_rules_execution_chcon</a></li>

<li><a href="#audit_rules_execution_chmod">audit_rules_execution_chmod</a></li>

<li><a href="#audit_rules_execution_restorecon">audit_rules_execution_restorecon</a></li>

<li><a href="#audit_rules_execution_rm">audit_rules_execution_rm</a></li>

<li><a href="#audit_rules_execution_semanage">audit_rules_execution_semanage</a></li>

<li><a href="#audit_rules_execution_setfacl">audit_rules_execution_setfacl</a></li>

<li><a href="#audit_rules_execution_setfiles">audit_rules_execution_setfiles</a></li>

<li><a href="#audit_rules_execution_setsebool">audit_rules_execution_setsebool</a></li>

<li><a href="#audit_rules_execution_seunshare">audit_rules_execution_seunshare</a></li>

<li><a href="#audit_rules_file_deletion_events">audit_rules_file_deletion_events</a></li>

<li><a href="#audit_rules_file_deletion_events_rename">audit_rules_file_deletion_events_rename</a></li>

<li><a href="#audit_rules_file_deletion_events_renameat">audit_rules_file_deletion_events_renameat</a></li>

<li><a href="#audit_rules_file_deletion_events_renameat2">audit_rules_file_deletion_events_renameat2</a></li>

<li><a href="#audit_rules_file_deletion_events_rmdir">audit_rules_file_deletion_events_rmdir</a></li>

<li><a href="#audit_rules_file_deletion_events_unlink">audit_rules_file_deletion_events_unlink</a></li>

<li><a href="#audit_rules_file_deletion_events_unlinkat">audit_rules_file_deletion_events_unlinkat</a></li>

<li><a href="#audit_rules_for_ospp">audit_rules_for_ospp</a></li>

<li><a href="#audit_rules_immutable">audit_rules_immutable</a></li>

<li><a href="#audit_rules_immutable_login_uids">audit_rules_immutable_login_uids</a></li>

<li><a href="#audit_rules_kernel_module_loading">audit_rules_kernel_module_loading</a></li>

<li><a href="#audit_rules_kernel_module_loading_create">audit_rules_kernel_module_loading_create</a></li>

<li><a href="#audit_rules_kernel_module_loading_delete">audit_rules_kernel_module_loading_delete</a></li>

<li><a href="#audit_rules_kernel_module_loading_finit">audit_rules_kernel_module_loading_finit</a></li>

<li><a href="#audit_rules_kernel_module_loading_init">audit_rules_kernel_module_loading_init</a></li>

<li><a href="#audit_rules_kernel_module_loading_query">audit_rules_kernel_module_loading_query</a></li>

<li><a href="#audit_rules_login_events">audit_rules_login_events</a></li>

<li><a href="#audit_rules_login_events_faillock">audit_rules_login_events_faillock</a></li>

<li><a href="#audit_rules_login_events_faillog">audit_rules_login_events_faillog</a></li>

<li><a href="#audit_rules_login_events_lastlog">audit_rules_login_events_lastlog</a></li>

<li><a href="#audit_rules_login_events_tallylog">audit_rules_login_events_tallylog</a></li>

<li><a href="#audit_rules_mac_modification">audit_rules_mac_modification</a></li>

<li><a href="#audit_rules_mac_modification_etc_apparmor">audit_rules_mac_modification_etc_apparmor</a></li>

<li><a href="#audit_rules_mac_modification_etc_apparmor_d">audit_rules_mac_modification_etc_apparmor_d</a></li>

<li><a href="#audit_rules_mac_modification_etc_selinux">audit_rules_mac_modification_etc_selinux</a></li>

<li><a href="#audit_rules_mac_modification_usr_share">audit_rules_mac_modification_usr_share</a></li>

<li><a href="#audit_rules_media_export">audit_rules_media_export</a></li>

<li><a href="#audit_rules_networkconfig_modification">audit_rules_networkconfig_modification</a></li>

<li><a href="#audit_rules_networkconfig_modification_hostname_file">audit_rules_networkconfig_modification_hostname_file</a></li>

<li><a href="#audit_rules_networkconfig_modification_network_scripts">audit_rules_networkconfig_modification_network_scripts</a></li>

<li><a href="#audit_rules_networkconfig_modification_networkmanager">audit_rules_networkconfig_modification_networkmanager</a></li>

<li><a href="#audit_rules_privileged_commands">audit_rules_privileged_commands</a></li>

<li><a href="#audit_rules_privileged_commands_apparmor_parser">audit_rules_privileged_commands_apparmor_parser</a></li>

<li><a href="#audit_rules_privileged_commands_at">audit_rules_privileged_commands_at</a></li>

<li><a href="#audit_rules_privileged_commands_chage">audit_rules_privileged_commands_chage</a></li>

<li><a href="#audit_rules_privileged_commands_chfn">audit_rules_privileged_commands_chfn</a></li>

<li><a href="#audit_rules_privileged_commands_chsh">audit_rules_privileged_commands_chsh</a></li>

<li><a href="#audit_rules_privileged_commands_crontab">audit_rules_privileged_commands_crontab</a></li>

<li><a href="#audit_rules_privileged_commands_dbus_daemon_launch_helper">audit_rules_privileged_commands_dbus_daemon_launch_helper</a></li>

<li><a href="#audit_rules_privileged_commands_fdisk">audit_rules_privileged_commands_fdisk</a></li>

<li><a href="#audit_rules_privileged_commands_fusermount">audit_rules_privileged_commands_fusermount</a></li>

<li><a href="#audit_rules_privileged_commands_fusermount3">audit_rules_privileged_commands_fusermount3</a></li>

<li><a href="#audit_rules_privileged_commands_gpasswd">audit_rules_privileged_commands_gpasswd</a></li>

<li><a href="#audit_rules_privileged_commands_grub2_set_bootflag">audit_rules_privileged_commands_grub2_set_bootflag</a></li>

<li><a href="#audit_rules_privileged_commands_insmod">audit_rules_privileged_commands_insmod</a></li>

<li><a href="#audit_rules_privileged_commands_kmod">audit_rules_privileged_commands_kmod</a></li>

<li><a href="#audit_rules_privileged_commands_modprobe">audit_rules_privileged_commands_modprobe</a></li>

<li><a href="#audit_rules_privileged_commands_mount">audit_rules_privileged_commands_mount</a></li>

<li><a href="#audit_rules_privileged_commands_mount_nfs">audit_rules_privileged_commands_mount_nfs</a></li>

<li><a href="#audit_rules_privileged_commands_newgidmap">audit_rules_privileged_commands_newgidmap</a></li>

<li><a href="#audit_rules_privileged_commands_newgrp">audit_rules_privileged_commands_newgrp</a></li>

<li><a href="#audit_rules_privileged_commands_newuidmap">audit_rules_privileged_commands_newuidmap</a></li>

<li><a href="#audit_rules_privileged_commands_pam_timestamp_check">audit_rules_privileged_commands_pam_timestamp_check</a></li>

<li><a href="#audit_rules_privileged_commands_passmass">audit_rules_privileged_commands_passmass</a></li>

<li><a href="#audit_rules_privileged_commands_passwd">audit_rules_privileged_commands_passwd</a></li>

<li><a href="#audit_rules_privileged_commands_pkexec">audit_rules_privileged_commands_pkexec</a></li>

<li><a href="#audit_rules_privileged_commands_polkit_helper">audit_rules_privileged_commands_polkit_helper</a></li>

<li><a href="#audit_rules_privileged_commands_postdrop">audit_rules_privileged_commands_postdrop</a></li>

<li><a href="#audit_rules_privileged_commands_postqueue">audit_rules_privileged_commands_postqueue</a></li>

<li><a href="#audit_rules_privileged_commands_pt_chown">audit_rules_privileged_commands_pt_chown</a></li>

<li><a href="#audit_rules_privileged_commands_rmmod">audit_rules_privileged_commands_rmmod</a></li>

<li><a href="#audit_rules_privileged_commands_sssd_krb5_child">audit_rules_privileged_commands_sssd_krb5_child</a></li>

<li><a href="#audit_rules_privileged_commands_sssd_ldap_child">audit_rules_privileged_commands_sssd_ldap_child</a></li>

<li><a href="#audit_rules_privileged_commands_sssd_proxy_child">audit_rules_privileged_commands_sssd_proxy_child</a></li>

<li><a href="#audit_rules_privileged_commands_sssd_selinux_child">audit_rules_privileged_commands_sssd_selinux_child</a></li>

<li><a href="#audit_rules_privileged_commands_ssh_agent">audit_rules_privileged_commands_ssh_agent</a></li>

<li><a href="#audit_rules_privileged_commands_ssh_keysign">audit_rules_privileged_commands_ssh_keysign</a></li>

<li><a href="#audit_rules_privileged_commands_su">audit_rules_privileged_commands_su</a></li>

<li><a href="#audit_rules_privileged_commands_sudo">audit_rules_privileged_commands_sudo</a></li>

<li><a href="#audit_rules_privileged_commands_sudoedit">audit_rules_privileged_commands_sudoedit</a></li>

<li><a href="#audit_rules_privileged_commands_umount">audit_rules_privileged_commands_umount</a></li>

<li><a href="#audit_rules_privileged_commands_unix2_chkpwd">audit_rules_privileged_commands_unix2_chkpwd</a></li>

<li><a href="#audit_rules_privileged_commands_unix_chkpwd">audit_rules_privileged_commands_unix_chkpwd</a></li>

<li><a href="#audit_rules_privileged_commands_unix_update">audit_rules_privileged_commands_unix_update</a></li>

<li><a href="#audit_rules_privileged_commands_userhelper">audit_rules_privileged_commands_userhelper</a></li>

<li><a href="#audit_rules_privileged_commands_usermod">audit_rules_privileged_commands_usermod</a></li>

<li><a href="#audit_rules_privileged_commands_usernetctl">audit_rules_privileged_commands_usernetctl</a></li>

<li><a href="#audit_rules_privileged_commands_utempter">audit_rules_privileged_commands_utempter</a></li>

<li><a href="#audit_rules_privileged_commands_write">audit_rules_privileged_commands_write</a></li>

<li><a href="#audit_rules_session_events">audit_rules_session_events</a></li>

<li><a href="#audit_rules_session_events_btmp">audit_rules_session_events_btmp</a></li>

<li><a href="#audit_rules_session_events_utmp">audit_rules_session_events_utmp</a></li>

<li><a href="#audit_rules_session_events_wtmp">audit_rules_session_events_wtmp</a></li>

<li><a href="#audit_rules_successful_file_modification_chmod">audit_rules_successful_file_modification_chmod</a></li>

<li><a href="#audit_rules_successful_file_modification_chown">audit_rules_successful_file_modification_chown</a></li>

<li><a href="#audit_rules_successful_file_modification_creat">audit_rules_successful_file_modification_creat</a></li>

<li><a href="#audit_rules_successful_file_modification_fchmod">audit_rules_successful_file_modification_fchmod</a></li>

<li><a href="#audit_rules_successful_file_modification_fchmodat">audit_rules_successful_file_modification_fchmodat</a></li>

<li><a href="#audit_rules_successful_file_modification_fchown">audit_rules_successful_file_modification_fchown</a></li>

<li><a href="#audit_rules_successful_file_modification_fchownat">audit_rules_successful_file_modification_fchownat</a></li>

<li><a href="#audit_rules_successful_file_modification_fremovexattr">audit_rules_successful_file_modification_fremovexattr</a></li>

<li><a href="#audit_rules_successful_file_modification_fsetxattr">audit_rules_successful_file_modification_fsetxattr</a></li>

<li><a href="#audit_rules_successful_file_modification_ftruncate">audit_rules_successful_file_modification_ftruncate</a></li>

<li><a href="#audit_rules_successful_file_modification_lchown">audit_rules_successful_file_modification_lchown</a></li>

<li><a href="#audit_rules_successful_file_modification_lremovexattr">audit_rules_successful_file_modification_lremovexattr</a></li>

<li><a href="#audit_rules_successful_file_modification_lsetxattr">audit_rules_successful_file_modification_lsetxattr</a></li>

<li><a href="#audit_rules_successful_file_modification_open">audit_rules_successful_file_modification_open</a></li>

<li><a href="#audit_rules_successful_file_modification_open_by_handle_at">audit_rules_successful_file_modification_open_by_handle_at</a></li>

<li><a href="#audit_rules_successful_file_modification_open_by_handle_at_o_creat">audit_rules_successful_file_modification_open_by_handle_at_o_creat</a></li>

<li><a href="#audit_rules_successful_file_modification_open_by_handle_at_o_trunc_write">audit_rules_successful_file_modification_open_by_handle_at_o_trunc_write</a></li>

<li><a href="#audit_rules_successful_file_modification_open_o_creat">audit_rules_successful_file_modification_open_o_creat</a></li>

<li><a href="#audit_rules_successful_file_modification_open_o_trunc_write">audit_rules_successful_file_modification_open_o_trunc_write</a></li>

<li><a href="#audit_rules_successful_file_modification_openat">audit_rules_successful_file_modification_openat</a></li>

<li><a href="#audit_rules_successful_file_modification_openat_o_creat">audit_rules_successful_file_modification_openat_o_creat</a></li>

<li><a href="#audit_rules_successful_file_modification_openat_o_trunc_write">audit_rules_successful_file_modification_openat_o_trunc_write</a></li>

<li><a href="#audit_rules_successful_file_modification_removexattr">audit_rules_successful_file_modification_removexattr</a></li>

<li><a href="#audit_rules_successful_file_modification_rename">audit_rules_successful_file_modification_rename</a></li>

<li><a href="#audit_rules_successful_file_modification_renameat">audit_rules_successful_file_modification_renameat</a></li>

<li><a href="#audit_rules_successful_file_modification_setxattr">audit_rules_successful_file_modification_setxattr</a></li>

<li><a href="#audit_rules_successful_file_modification_truncate">audit_rules_successful_file_modification_truncate</a></li>

<li><a href="#audit_rules_successful_file_modification_unlink">audit_rules_successful_file_modification_unlink</a></li>

<li><a href="#audit_rules_successful_file_modification_unlinkat">audit_rules_successful_file_modification_unlinkat</a></li>

<li><a href="#audit_rules_sudoers">audit_rules_sudoers</a></li>

<li><a href="#audit_rules_sudoers_d">audit_rules_sudoers_d</a></li>

<li><a href="#audit_rules_suid_privilege_function">audit_rules_suid_privilege_function</a></li>

<li><a href="#audit_rules_suid_auid_privilege_function">audit_rules_suid_auid_privilege_function</a></li>

<li><a href="#audit_rules_sysadmin_actions">audit_rules_sysadmin_actions</a></li>

<li><a href="#audit_rules_system_shutdown">audit_rules_system_shutdown</a></li>

<li><a href="#audit_rules_time_adjtimex">audit_rules_time_adjtimex</a></li>

<li><a href="#audit_rules_time_clock_settime">audit_rules_time_clock_settime</a></li>

<li><a href="#audit_rules_time_settimeofday">audit_rules_time_settimeofday</a></li>

<li><a href="#audit_rules_time_stime">audit_rules_time_stime</a></li>

<li><a href="#audit_rules_time_watch_localtime">audit_rules_time_watch_localtime</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification">audit_rules_unsuccessful_file_modification</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_chmod">audit_rules_unsuccessful_file_modification_chmod</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_chown">audit_rules_unsuccessful_file_modification_chown</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_creat">audit_rules_unsuccessful_file_modification_creat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fchmod">audit_rules_unsuccessful_file_modification_fchmod</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fchmodat">audit_rules_unsuccessful_file_modification_fchmodat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fchown">audit_rules_unsuccessful_file_modification_fchown</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fchownat">audit_rules_unsuccessful_file_modification_fchownat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fremovexattr">audit_rules_unsuccessful_file_modification_fremovexattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_fsetxattr">audit_rules_unsuccessful_file_modification_fsetxattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_ftruncate">audit_rules_unsuccessful_file_modification_ftruncate</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_lchown">audit_rules_unsuccessful_file_modification_lchown</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_lremovexattr">audit_rules_unsuccessful_file_modification_lremovexattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_lsetxattr">audit_rules_unsuccessful_file_modification_lsetxattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open">audit_rules_unsuccessful_file_modification_open</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_by_handle_at">audit_rules_unsuccessful_file_modification_open_by_handle_at</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_by_handle_at_o_creat">audit_rules_unsuccessful_file_modification_open_by_handle_at_o_creat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_by_handle_at_o_trunc_write">audit_rules_unsuccessful_file_modification_open_by_handle_at_o_trunc_write</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_by_handle_at_rule_order">audit_rules_unsuccessful_file_modification_open_by_handle_at_rule_order</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_o_creat">audit_rules_unsuccessful_file_modification_open_o_creat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_o_trunc_write">audit_rules_unsuccessful_file_modification_open_o_trunc_write</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_open_rule_order">audit_rules_unsuccessful_file_modification_open_rule_order</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_openat">audit_rules_unsuccessful_file_modification_openat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_openat_o_creat">audit_rules_unsuccessful_file_modification_openat_o_creat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_openat_o_trunc_write">audit_rules_unsuccessful_file_modification_openat_o_trunc_write</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_openat_rule_order">audit_rules_unsuccessful_file_modification_openat_rule_order</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_removexattr">audit_rules_unsuccessful_file_modification_removexattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_rename">audit_rules_unsuccessful_file_modification_rename</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_renameat">audit_rules_unsuccessful_file_modification_renameat</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_renameat2">audit_rules_unsuccessful_file_modification_renameat2</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_setxattr">audit_rules_unsuccessful_file_modification_setxattr</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_truncate">audit_rules_unsuccessful_file_modification_truncate</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_unlink">audit_rules_unsuccessful_file_modification_unlink</a></li>

<li><a href="#audit_rules_unsuccessful_file_modification_unlinkat">audit_rules_unsuccessful_file_modification_unlinkat</a></li>

<li><a href="#audit_rules_usergroup_modification">audit_rules_usergroup_modification</a></li>

<li><a href="#audit_rules_usergroup_modification_group">audit_rules_usergroup_modification_group</a></li>

<li><a href="#audit_rules_usergroup_modification_gshadow">audit_rules_usergroup_modification_gshadow</a></li>

<li><a href="#audit_rules_usergroup_modification_opasswd">audit_rules_usergroup_modification_opasswd</a></li>

<li><a href="#audit_rules_usergroup_modification_passwd">audit_rules_usergroup_modification_passwd</a></li>

<li><a href="#audit_rules_usergroup_modification_shadow">audit_rules_usergroup_modification_shadow</a></li>

<li><a href="#audit_rules_usergroup_modification_nsswitch_conf">audit_rules_usergroup_modification_nsswitch_conf</a></li>

<li><a href="#audit_rules_usergroup_modification_pam_conf">audit_rules_usergroup_modification_pam_conf</a></li>

<li><a href="#audit_rules_usergroup_modification_pamd">audit_rules_usergroup_modification_pamd</a></li>

<li><a href="#audit_rules_var_log_journal">audit_rules_var_log_journal</a></li>

<li><a href="#audit_sudo_log_events">audit_sudo_log_events</a></li>

<li><a href="#auditd_audispd_configure_remote_server">auditd_audispd_configure_remote_server</a></li>

<li><a href="#auditd_audispd_configure_sufficiently_large_partition">auditd_audispd_configure_sufficiently_large_partition</a></li>

<li><a href="#auditd_audispd_disk_full_action">auditd_audispd_disk_full_action</a></li>

<li><a href="#auditd_audispd_encrypt_sent_records">auditd_audispd_encrypt_sent_records</a></li>

<li><a href="#auditd_audispd_network_failure_action">auditd_audispd_network_failure_action</a></li>

<li><a href="#auditd_audispd_remote_daemon_activated">auditd_audispd_remote_daemon_activated</a></li>

<li><a href="#auditd_audispd_remote_daemon_direction">auditd_audispd_remote_daemon_direction</a></li>

<li><a href="#auditd_audispd_remote_daemon_path">auditd_audispd_remote_daemon_path</a></li>

<li><a href="#auditd_audispd_remote_daemon_type">auditd_audispd_remote_daemon_type</a></li>

<li><a href="#auditd_audispd_syslog_plugin_activated">auditd_audispd_syslog_plugin_activated</a></li>

<li><a href="#auditd_data_disk_error_action">auditd_data_disk_error_action</a></li>

<li><a href="#auditd_data_disk_error_action_stig">auditd_data_disk_error_action_stig</a></li>

<li><a href="#auditd_data_disk_full_action">auditd_data_disk_full_action</a></li>

<li><a href="#auditd_data_disk_full_action_stig">auditd_data_disk_full_action_stig</a></li>

<li><a href="#auditd_data_retention_action_mail_acct">auditd_data_retention_action_mail_acct</a></li>

<li><a href="#auditd_data_retention_admin_space_left_action">auditd_data_retention_admin_space_left_action</a></li>

<li><a href="#auditd_data_retention_admin_space_left_percentage">auditd_data_retention_admin_space_left_percentage</a></li>

<li><a href="#auditd_data_retention_flush">auditd_data_retention_flush</a></li>

<li><a href="#auditd_data_retention_max_log_file">auditd_data_retention_max_log_file</a></li>

<li><a href="#auditd_data_retention_max_log_file_action">auditd_data_retention_max_log_file_action</a></li>

<li><a href="#auditd_data_retention_max_log_file_action_stig">auditd_data_retention_max_log_file_action_stig</a></li>

<li><a href="#auditd_data_retention_num_logs">auditd_data_retention_num_logs</a></li>

<li><a href="#auditd_data_retention_space_left">auditd_data_retention_space_left</a></li>

<li><a href="#auditd_data_retention_space_left_action">auditd_data_retention_space_left_action</a></li>

<li><a href="#auditd_data_retention_space_left_percentage">auditd_data_retention_space_left_percentage</a></li>

<li><a href="#auditd_freq">auditd_freq</a></li>

<li><a href="#auditd_local_events">auditd_local_events</a></li>

<li><a href="#auditd_log_format">auditd_log_format</a></li>

<li><a href="#auditd_name_format">auditd_name_format</a></li>

<li><a href="#auditd_offload_logs">auditd_offload_logs</a></li>

<li><a href="#auditd_overflow_action">auditd_overflow_action</a></li>

<li><a href="#auditd_write_logs">auditd_write_logs</a></li>

<li><a href="#coreos_audit_backlog_limit_kernel_argument">coreos_audit_backlog_limit_kernel_argument</a></li>

<li><a href="#coreos_audit_option">coreos_audit_option</a></li>

<li><a href="#directory_access_var_log_audit">directory_access_var_log_audit</a></li>

<li><a href="#directory_group_ownership_var_log_audit">directory_group_ownership_var_log_audit</a></li>

<li><a href="#directory_ownership_var_log_audit">directory_ownership_var_log_audit</a></li>

<li><a href="#directory_permissions_var_log_audit">directory_permissions_var_log_audit</a></li>

<li><a href="#file_group_ownership_var_log_audit">file_group_ownership_var_log_audit</a></li>

<li><a href="#file_group_ownership_var_log_audit_stig">file_group_ownership_var_log_audit_stig</a></li>

<li><a href="#file_groupownership_audit_configuration">file_groupownership_audit_configuration</a></li>

<li><a href="#file_ownership_audit_configuration">file_ownership_audit_configuration</a></li>

<li><a href="#file_ownership_var_log_audit">file_ownership_var_log_audit</a></li>

<li><a href="#file_ownership_var_log_audit_stig">file_ownership_var_log_audit_stig</a></li>

<li><a href="#file_permissions_audit_configuration">file_permissions_audit_configuration</a></li>

<li><a href="#file_permissions_etc_audit_auditd">file_permissions_etc_audit_auditd</a></li>

<li><a href="#file_permissions_etc_audit_rulesd">file_permissions_etc_audit_rulesd</a></li>

<li><a href="#file_permissions_etc_audit_rules">file_permissions_etc_audit_rules</a></li>

<li><a href="#file_permissions_var_log_audit">file_permissions_var_log_audit</a></li>

<li><a href="#file_permissions_var_log_audit_stig">file_permissions_var_log_audit_stig</a></li>

<li><a href="#grub2_audit_argument">grub2_audit_argument</a></li>

<li><a href="#grub2_audit_backlog_limit_argument">grub2_audit_backlog_limit_argument</a></li>

<li><a href="#package_audispd-plugins_installed">package_audispd-plugins_installed</a></li>

<li><a href="#package_audit-audispd-plugins_installed">package_audit-audispd-plugins_installed</a></li>

<li><a href="#package_audit-libs_installed">package_audit-libs_installed</a></li>

<li><a href="#package_audit_installed">package_audit_installed</a></li>

<li><a href="#service_auditd_enabled">service_auditd_enabled</a></li>

<li><a href="#audit_rules_etc_cron_d">audit_rules_etc_cron_d</a></li>

<li><a href="#audit_rules_var_spool_cron">audit_rules_var_spool_cron</a></li>

</ul>



<h2>Rule details</h2>


<div id="audit_access_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file accesses</h3>
<div>audit_access_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.</p>
</div>

<div id="audit_access_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file accesses (AArch64)</h3>
<div>audit_access_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.</p>
</div>

<div id="audit_access_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file accesses (ppc64le)</h3>
<div>audit_access_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file access (any other opens) This has to go last.
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access a file might be signs of malicious activity happening within the system. Auditing of such activities helps in their monitoring and investigation.</p>
</div>

<div id="audit_access_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file accesses</h3>
<div>audit_access_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to access a file helps in investigation of activities performed on the system.</p>
</div>

<div id="audit_access_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file accesses (AArch64)</h3>
<div>audit_access_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b32 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access
-a always,exit -F arch=b64 -S openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to access a file helps in investigation of activities performed on the system.</p>
</div>

<div id="audit_access_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file accesses (ppc64le)</h3>
<div>audit_access_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to access a file are audited.

The following rules configure audit as described above:
<pre>## Successful file access (any other opens) This has to go last.
## These next two are likely to result in a whole lot of events
-a always,exit -F arch=b64 -S open,openat,openat2,open_by_handle_at -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-access    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to access a file helps in investigation of activities performed on the system.</p>
</div>

<div id="audit_basic_configuration" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure basic parameters of Audit system</h3>
<div>audit_basic_configuration</div>
<h4>Description</h4>
<p>Perform basic configuration of Audit system.
Make sure that any previously defined rules are cleared, the auditing system is configured to handle sudden bursts of events, and in cases of failure, messages are configured to be directed to system log.

The following rules configure audit as described above:
<pre>## First rule - delete all
-D

## Increase the buffers to survive stress events.
## Make this bigger for busy systems
-b 8192

## This determine how long to wait in burst of events
--backlog_wait_time 60000

## Set failure mode to syslog
-f 1    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre></p>
<h4>Rationale</h4>
<p>Without basic configurations, audit may not perform as expected. It may not be able to correctly handle events under stressful conditions, or log events in case of failure.</p>
</div>

<div id="audit_create_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file creations</h3>
<div>audit_create_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.</p>
</div>

<div id="audit_create_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file creations (AArch64)</h3>
<div>audit_create_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.</p>
</div>

<div id="audit_create_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file creations (ppc64le)</h3>
<div>audit_create_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file creation (open with O_CREAT)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file creations might be a sign of a malicious action being performed on the system. Keeping log of such events helps in monitoring and investigation of such actions.</p>
</div>

<div id="audit_create_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file creations</h3>
<div>audit_create_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_create_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file creations (AArch64)</h3>
<div>audit_create_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b32 -S creat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_create_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file creations (ppc64le)</h3>
<div>audit_create_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to create a file are audited.

The following rules configure audit as described above:
<pre>## Successful file creation (open with O_CREAT)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
-a always,exit -F arch=b64 -S creat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to create a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_delete_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file deletions</h3>
<div>audit_delete_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.</p>
</div>

<div id="audit_delete_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file deletions (AArch64)</h3>
<div>audit_delete_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.</p>
</div>

<div id="audit_delete_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file deletions (ppc64le)</h3>
<div>audit_delete_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete a file might be signs of malicious activities. Auditing of such events help in monitoring and investigating of such activities.</p>
</div>

<div id="audit_delete_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file deletions</h3>
<div>audit_delete_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.</p>
</div>

<div id="audit_delete_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file deletions (AArch64)</h3>
<div>audit_delete_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b32 -S unlink,unlinkat,rename,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete
-a always,exit -F arch=b64 -S unlinkat,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.</p>
</div>

<div id="audit_delete_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file deletions (ppc64le)</h3>
<div>audit_delete_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to delete a file are audited.

The following rules configure audit as described above:
<pre>## Successful file delete
-a always,exit -F arch=b64 -S unlink,unlinkat,rename,renameat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-delete    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to delete a file may help in monitoring and investigation of activities performed on the system.</p>
</div>

<div id="audit_immutable_login_uids" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure immutable Audit login UIDs</h3>
<div>audit_immutable_login_uids</div>
<h4>Description</h4>
<p>Configure kernel to prevent modification of login UIDs once they are set.
Changing login UIDs while this configuration is enforced requires special capabilities which
are not available to unprivileged users.

The following rules configure audit as described above:
<pre>## Make the loginuid immutable. This prevents tampering with the auid.
--loginuid-immutable    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre></p>
<h4>Rationale</h4>
<p>If modification of login UIDs is not prevented, they can be changed by unprivileged users and
make auditing complicated or impossible.</p>
</div>

<div id="audit_modify_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file modifications</h3>
<div>audit_modify_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.</p>
</div>

<div id="audit_modify_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file modifications (AARch64)</h3>
<div>audit_modify_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.</p>
</div>

<div id="audit_modify_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful file modifications (ppc64le)</h3>
<div>audit_modify_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful file modifications (open for write or truncate)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful file modifications might be a sign of a malicious action being performed on the system. Auditing of such events helps in detection and investigation of such actions.</p>
</div>

<div id="audit_modify_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file modifications</h3>
<div>audit_modify_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_modify_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file modifications (AArch64)</h3>
<div>audit_modify_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b32 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_modify_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful file modifications (ppc64le)</h3>
<div>audit_modify_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify a file are audited.

The following rules configure audit as described above:
<pre>## Successful file modifications (open for write or truncate)
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
-a always,exit -F arch=b64 -S truncate,ftruncate -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful attempts to modify a file helps in investigation of actions which happened on the system.</p>
</div>

<div id="audit_module_load" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of loading and unloading of kernel modules</h3>
<div>audit_module_load</div>
<h4>Description</h4>
<p>Ensure that loading and unloading of kernel modules is audited.

The following rules configure audit as described above:
<pre>## These rules watch for kernel module insertion. By monitoring
## the syscall, we do not need any watches on programs.
-a always,exit -F arch=b32 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b64 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b32 -S delete_module -F key=module-unload
-a always,exit -F arch=b64 -S delete_module -F key=module-unload    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre></p>
<h4>Rationale</h4>
<p>Loading of a malicious kernel module introduces a risk to the system, as the module has access to sensitive data and perform actions at the operating system kernel level. Having such events audited helps in monitoring and investigating of malicious activities.</p>
</div>

<div id="audit_module_load_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of loading and unloading of kernel modules (ppc64le)</h3>
<div>audit_module_load_ppc64le</div>
<h4>Description</h4>
<p>Ensure that loading and unloading of kernel modules is audited.

The following rules configure audit as described above:
<pre>## These rules watch for kernel module insertion. By monitoring
## the syscall, we do not need any watches on programs.
-a always,exit -F arch=b64 -S init_module,finit_module -F key=module-load
-a always,exit -F arch=b64 -S delete_module -F key=module-unload    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre></p>
<h4>Rationale</h4>
<p>Loading of a malicious kernel module introduces a risk to the system, as the module has access to sensitive data and perform actions at the operating system kernel level. Having such events audited helps in monitoring and investigating of malicious activities.</p>
</div>

<div id="audit_ospp_general" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Perform general configuration of Audit for OSPP</h3>
<div>audit_ospp_general</div>
<h4>Description</h4>
<p>Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F arch=b32 -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b64 -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b32 -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b64 -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F arch=b32 -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F arch=b32 -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
-a always,exit -F arch=b64 -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F arch=b32 -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation
-a always,exit -F arch=b64 -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F arch=b32 -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b32 -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b64 -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F arch=b32 -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
-a always,exit -F arch=b64 -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F arch=b32 -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b32 -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b32 -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F arch=b32 -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy
-a always,exit -F arch=b64 -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.</p>
</div>

<div id="audit_ospp_general_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Perform general configuration of Audit for OSPP (AArch64)</h3>
<div>audit_ospp_general_aarch64</div>
<h4>Description</h4>
<p>Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F arch=b32 -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b32 -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b64 -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b32 -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b64 -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F arch=b32 -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b32 -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F arch=b32 -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
-a always,exit -F arch=b64 -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F arch=b32 -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation
-a always,exit -F arch=b64 -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F arch=b32 -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b32 -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b64 -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F arch=b32 -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
-a always,exit -F arch=b64 -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F arch=b32 -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b32 -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b32 -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F arch=b32 -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy
-a always,exit -F arch=b64 -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.</p>
</div>

<div id="audit_ospp_general_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Perform general configuration of Audit for OSPP (ppc64le)</h3>
<div>audit_ospp_general_ppc64le</div>
<h4>Description</h4>
<p>Configure some basic <tt>Audit</tt> parameters specific for OSPP profile.
In particular, configure <tt>Audit</tt> to watch for direct modification of files storing system user and group information, and usage of applications with special rights which can change system configuration.
Further audited events include access to audit log it self, attempts to Alter Process and Session Initiation Information, and attempts to modify MAC controls.

The following rules configure audit as described above:
<pre>## The purpose of these rules is to meet the requirements for Operating
## System Protection Profile (OSPP)v4.2. These rules depends on having
## the following rule files copied to /etc/audit/rules.d:
##
## 10-base-config.rules, 11-loginuid.rules,
## 30-ospp-v42-1-create-failed.rules, 30-ospp-v42-1-create-success.rules,
## 30-ospp-v42-2-modify-failed.rules, 30-ospp-v42-2-modify-success.rules,
## 30-ospp-v42-3-access-failed.rules, 30-ospp-v42-3-access-success.rules,
## 30-ospp-v42-4-delete-failed.rules, 30-ospp-v42-4-delete-success.rules,
## 30-ospp-v42-5-perm-change-failed.rules,
## 30-ospp-v42-5-perm-change-success.rules,
## 30-ospp-v42-6-owner-change-failed.rules,
## 30-ospp-v42-6-owner-change-success.rules
##
## original copies may be found in /usr/share/audit/sample-rules/


## User add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch passwd and
## shadow for writes
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S openat,open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify

## User enable and disable. This is entirely handled by pam.

## Group add delete modify. This is covered by pam. However, someone could
## open a file and directly create or modify a user, so we'll watch group and
## gshadow for writes
-a always,exit -F arch=b64 -F path=/etc/passwd -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/shadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=user-modify
-a always,exit -F arch=b64 -F path=/etc/group -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify
-a always,exit -F arch=b64 -F path=/etc/gshadow -F perm=wa -F auid>=1000 -F auid!=unset -F key=group-modify


## Use of special rights for config changes. This would be use of setuid
## programs that relate to user accts. This is not all setuid apps because
## requirements are only for ones that affect system configuration.
-a always,exit -F arch=b64 -F path=/usr/sbin/unix_chkpwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/usernetctl -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/userhelper -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/seunshare -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/mount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgrp -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newuidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/gpasswd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/newgidmap -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/umount -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/passwd -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/crontab -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/bin/at -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes
-a always,exit -F arch=b64 -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid>=1000 -F auid!=unset -F key=special-config-changes

## Privilege escalation via su or sudo. This is entirely handled by pam.
## Special case for systemd-run. It is not audit aware, specifically watch it
-a always,exit -F arch=b64 -F path=/usr/bin/systemd-run -F perm=x -F auid!=unset -F key=maybe-escalation
## Special case for pkexec. It is not audit aware, specifically watch it
-a always,exit -F arch=b64 -F path=/usr/bin/pkexec -F perm=x -F key=maybe-escalation


## Watch for configuration changes to privilege escalation.
-a always,exit -F arch=b64 -F path=/etc/sudoers -F perm=wa -F key=special-config-changes
-a always,exit -F arch=b64 -F dir=/etc/sudoers.d/ -F perm=wa -F key=special-config-changes

## Audit log access
-a always,exit -F arch=b64 -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail
## Attempts to Alter Process and Session Initiation Information
-a always,exit -F arch=b64 -F path=/var/run/utmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/btmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session
-a always,exit -F arch=b64 -F path=/var/log/wtmp -F perm=wa -F auid>=1000 -F auid!=unset -F key=session

## Attempts to modify MAC controls
-a always,exit -F arch=b64 -F dir=/etc/selinux/ -F perm=wa -F auid>=1000 -F auid!=unset -F key=MAC-policy

## Software updates. This is entirely handled by rpm.

## System start and shutdown. This is entirely handled by systemd

## Kernel Module loading. This is handled in 43-module-load.rules

## Application invocation. The requirements list an optional requirement
## FPT_SRP_EXT.1 Software Restriction Policies. This event is intended to
## state results from that policy. This would be handled entirely by
## that daemon.    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of events listed in the description provides data for monitoring and investigation of potentially malicious events e.g. tampering with <tt>Audit</tt> logs, malicious access to files storing information about system users and groups etc.</p>
</div>

<div id="audit_owner_change_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful ownership changes</h3>
<div>audit_owner_change_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_owner_change_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful ownership changes (AArch64)</h3>
<div>audit_owner_change_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_owner_change_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful ownership changes (ppc64le)</h3>
<div>audit_owner_change_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful ownership change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change an ownership of files or directories might be signs of a malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_owner_change_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful ownership changes</h3>
<div>audit_owner_change_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-owner-change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful ownership changes of files or directories helps in monitoring or investigating of activities performed on the system.</p>
</div>

<div id="audit_owner_change_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful ownership changes (AArch64)</h3>
<div>audit_owner_change_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b32 -S lchown,fchown,chown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change
-a always,exit -F arch=b64 -S fchown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful ownership changes of files or directories helps in monitoring or investigating of activities performed on the system.</p>
</div>

<div id="audit_owner_change_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful ownership changes (ppc64le)</h3>
<div>audit_owner_change_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to change an ownership of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful ownership change
-a always,exit -F arch=b64 -S lchown,fchown,chown,fchownat -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-owner-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing of successful ownership changes of files or directories helps in monitoring or investigating of activities performed on the system.</p>
</div>

<div id="audit_perm_change_failed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful permission changes</h3>
<div>audit_perm_change_failed</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_perm_change_failed_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful permission changes (AArch64)</h3>
<div>audit_perm_change_failed_aarch64</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_perm_change_failed_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of unsuccessful permission changes (ppc64le)</h3>
<div>audit_perm_change_failed_ppc64le</div>
<h4>Description</h4>
<p>Ensure that unsuccessful attempts to change file or directory permissions are audited.

The following rules configure audit as described above:
<pre>## Unsuccessful permission change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccessful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files or directories might be signs of malicious activity. Having such events audited helps in monitoring and investigation of such activities.</p>
</div>

<div id="audit_perm_change_success" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful permission changes</h3>
<div>audit_perm_change_success</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.</p>
</div>

<div id="audit_perm_change_success_aarch64" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful permission changes (AArch64)</h3>
<div>audit_perm_change_success_aarch64</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b32 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change
-a always,exit -F arch=b64 -S fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.</p>
</div>

<div id="audit_perm_change_success_ppc64le" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditing of successful permission changes (ppc64le)</h3>
<div>audit_perm_change_success_ppc64le</div>
<h4>Description</h4>
<p>Ensure that successful attempts to modify permissions of files or directories are audited.

The following rules configure audit as described above:
<pre>## Successful permission change
-a always,exit -F arch=b64 -S chmod,fchmod,fchmodat,setxattr,lsetxattr,fsetxattr,removexattr,lremovexattr,fremovexattr -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-perm-change    </pre>

Load new Audit rules into kernel by running:
<pre>augenrules --load</pre>

Note: This rule uses a special set of Audit rules to comply with OSPP 4.2.1. You may reuse this rule in different profiles. If you decide to do so, it is recommended that you inspect contents of the file closely and make sure that they are aligned with your needs.</p>
<h4>Rationale</h4>
<p>Auditing successful file or directory permission changes helps in monitoring and investigating of activities performed on the system.</p>
</div>

<div id="audit_privileged_commands_init" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - init</h3>
<div>audit_privileged_commands_init</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/init -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/init -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of the init command may cause availability issues for the system.</p>
</div>

<div id="audit_privileged_commands_poweroff" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - poweroff</h3>
<div>audit_privileged_commands_poweroff</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/poweroff -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/poweroff -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of the poweroff command may cause availability issues for the system.</p>
</div>

<div id="audit_privileged_commands_reboot" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - reboot</h3>
<div>audit_privileged_commands_reboot</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/reboot -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/reboot -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of the reboot command may cause availability issues for the system.</p>
</div>

<div id="audit_privileged_commands_shutdown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - shutdown</h3>
<div>audit_privileged_commands_shutdown</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/shutdown -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/shutdown -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of the shutdown command may cause availability issues for the system.</p>
</div>

<div id="audit_rules_dac_modification_chmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - chmod</h3>
<div>audit_rules_dac_modification_chmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_chown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - chown</h3>
<div>audit_rules_dac_modification_chown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S chown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fchmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fchmod</h3>
<div>audit_rules_dac_modification_fchmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmod -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fchmodat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fchmodat</h3>
<div>audit_rules_dac_modification_fchmodat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fchmodat2" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fchmodat2</h3>
<div>audit_rules_dac_modification_fchmodat2</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchmodat2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmodat2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchmodat2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fchown</h3>
<div>audit_rules_dac_modification_fchown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>

If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fchownat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fchownat</h3>
<div>audit_rules_dac_modification_fchownat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fchownat -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fremovexattr</h3>
<div>audit_rules_dac_modification_fremovexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S fremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S fremovexattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_fsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - fsetxattr</h3>
<div>audit_rules_dac_modification_fsetxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S fsetxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S fsetxattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_lchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - lchown</h3>
<div>audit_rules_dac_modification_lchown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lchown -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_lremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - lremovexattr</h3>
<div>audit_rules_dac_modification_lremovexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S lremovexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S lremovexattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_lsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - lsetxattr</h3>
<div>audit_rules_dac_modification_lsetxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S lsetxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S lsetxattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_removexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - removexattr</h3>
<div>audit_rules_dac_modification_removexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root.
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following line to a file with suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S removexattr -F auid=0 -F key=perm_mod</pre>
<br /><br />
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S removexattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S removexattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_setxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - setxattr</h3>
<div>audit_rules_dac_modification_setxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission
changes for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b32 -S setxattr -F auid=0 -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S setxattr -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
<pre>-a always,exit -F arch=b64 -S setxattr -F auid=0 -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_umount" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - umount</h3>
<div>audit_rules_dac_modification_umount</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file system umount
changes. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S umount -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S umount -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_dac_modification_umount2" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Discretionary Access Controls - umount2</h3>
<div>audit_rules_dac_modification_umount2</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file system umount2
changes. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S umount2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S umount2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S umount2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S umount2 -F auid&gt;=1000 -F auid!=unset -F key=perm_mod</pre></p>
<h4>Rationale</h4>
<p>The changing of file permissions could indicate that a user is attempting to
gain access to information that would otherwise be disallowed. Auditing DAC modifications
can facilitate the identification of patterns of abuse among both authorized and
unauthorized users.</p>
</div>

<div id="audit_rules_enable_syscall_auditing" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Remove Default Configuration to Disable Syscall Auditing</h3>
<div>audit_rules_enable_syscall_auditing</div>
<h4>Description</h4>
<p>By default, Ubuntu 24.04 ships an audit rule to disable syscall
auditing for performance reasons.

To make sure that syscall auditing works, this line must be removed from
<tt>/etc/audit/rules.d/audit.rules</tt> and <tt>/etc/audit/audit.rules</tt>:

<pre>-a task,never</pre></p>
<h4>Rationale</h4>
<p>Audit rules for syscalls do not take effect unless this line is removed.</p>
</div>

<div id="audit_rules_etc_group_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open syscall - /etc/group</h3>
<div>audit_rules_etc_group_open</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/group file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_group_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/group</h3>
<div>audit_rules_etc_group_open_by_handle_at</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/group file for all group and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_group_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via openat syscall - /etc/group</h3>
<div>audit_rules_etc_group_openat</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/group file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/group -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of groups through direct edition of /etc/group could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_gshadow_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open syscall - /etc/gshadow</h3>
<div>audit_rules_etc_gshadow_open</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_gshadow_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/gshadow</h3>
<div>audit_rules_etc_gshadow_open_by_handle_at</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_gshadow_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via openat syscall - /etc/gshadow</h3>
<div>audit_rules_etc_gshadow_openat</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/gshadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/gshadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/gshadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_passwd_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open syscall - /etc/passwd</h3>
<div>audit_rules_etc_passwd_open</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_passwd_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/passwd</h3>
<div>audit_rules_etc_passwd_open_by_handle_at</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_passwd_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via openat syscall - /etc/passwd</h3>
<div>audit_rules_etc_passwd_openat</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/passwd file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/passwd -F auid>=1000 -F auid!=unset -F key=modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/passwd could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_shadow_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open syscall - /etc/shadow</h3>
<div>audit_rules_etc_shadow_open</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open -F a1&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_shadow_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via open_by_handle_at syscall - /etc/shadow</h3>
<div>audit_rules_etc_shadow_open_by_handle_at</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_etc_shadow_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information via openat syscall - /etc/shadow</h3>
<div>audit_rules_etc_shadow_openat</div>
<h4>Description</h4>
<p>The audit system should collect write events to /etc/shadow file for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S openat -F a2&amp;03 -F path=/etc/shadow -F auid>=1000 -F auid!=unset -F key=user-modify</pre></p>
<h4>Rationale</h4>
<p>Creation of users through direct edition of /etc/shadow could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_execution_chacl" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run chacl</h3>
<div>audit_rules_execution_chacl</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.
Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_execution_chcon" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run chcon</h3>
<div>audit_rules_execution_chcon</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chcon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_execution_chmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run chmod</h3>
<div>audit_rules_execution_chmod</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.

Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_execution_restorecon" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run restorecon</h3>
<div>audit_rules_execution_restorecon</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/restorecon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/restorecon -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_execution_rm" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run rm</h3>
<div>audit_rules_execution_rm</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/rm -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/rm -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.

Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_execution_semanage" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run semanage</h3>
<div>audit_rules_execution_semanage</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/semanage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_execution_setfacl" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run setfacl</h3>
<div>audit_rules_execution_setfacl</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/setfacl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.
Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_execution_setfiles" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run setfiles</h3>
<div>audit_rules_execution_setfiles</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/setfiles -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/setfiles -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_execution_setsebool" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run setsebool</h3>
<div>audit_rules_execution_setsebool</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/setsebool -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_execution_seunshare" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run seunshare</h3>
<div>audit_rules_execution_seunshare</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/seunshare -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_file_deletion_events" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User</h3>
<div>audit_rules_file_deletion_events</div>
<h4>Description</h4>
<p>At a minimum the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename,renameat,renameat2 -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rmdir,unlink,unlinkat,rename,renameat2 -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_rename" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - rename</h3>
<div>audit_rules_file_deletion_events_rename</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rename -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_renameat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - renameat</h3>
<div>audit_rules_file_deletion_events_renameat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S renameat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_renameat2" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - renameat2</h3>
<div>audit_rules_file_deletion_events_renameat2</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S renameat2 -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S renameat2 -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_rmdir" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - rmdir</h3>
<div>audit_rules_file_deletion_events_rmdir</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S rmdir -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_unlink" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - unlink</h3>
<div>audit_rules_file_deletion_events_unlink</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S unlink -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_file_deletion_events_unlinkat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects File Deletion Events by User - unlinkat</h3>
<div>audit_rules_file_deletion_events_unlinkat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file deletion events
for all users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S unlinkat -F auid&gt;=1000 -F auid!=unset -F key=delete</pre></p>
<h4>Rationale</h4>
<p>Auditing file deletions will create an audit trail for files that are removed
from the system. The audit trail could aid in system troubleshooting, as well as, detecting
malicious processes that attempt to delete log files to conceal their presence.</p>
</div>

<div id="audit_rules_for_ospp" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure audit according to OSPP requirements</h3>
<div>audit_rules_for_ospp</div>
<h4>Description</h4>
<p>Configure audit to meet requirements for Operating System Protection Profile (OSPP) v4.2.1.

Audit defines groups of rules in <tt>/usr/share/doc/audit/rules</tt> to satisfy specific policies.

To fulfill requirements for compliance with OSPP v4.2.1, the following files are necessary:
<ul>
<li>/usr/share/doc/audit/rules/10-base-config.rules</li>
<li>/usr/share/doc/audit/rules/11-loginuid.rules</li>
<li>/usr/share/doc/audit/rules/30-ospp-v42.rules</li>
<li>/usr/share/doc/audit/rules/43-module-load.rules</li>
</ul>

Copy the files from <tt>/usr/share/doc/audit/rules</tt> to <tt>/etc/audit/rules.d</tt>:
<pre>
cp /usr/share/doc/audit*/rules/{10-base-config,11-loginuid,30-ospp-v42,43-module-load}.rules /etc/audit/rules.d/
</pre></p>
<h4>Rationale</h4>
<p>The audit rules defined in <tt>/usr/share/doc/audit/rules</tt> are the recommended way to meet compliance with OSPP v4.2.1.</p>
</div>

<div id="audit_rules_immutable" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Make the auditd Configuration Immutable</h3>
<div>audit_rules_immutable</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to make the auditd configuration
immutable:
<pre>-e 2</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file in order to make the auditd configuration
immutable:
<pre>-e 2</pre>
With this setting, a reboot will be required to change any audit rules.</p>
<h4>Rationale</h4>
<p>Making the audit configuration immutable prevents accidental as
well as malicious modification of the audit rules, although it may be
problematic if legitimate changes are needed during system
operation.</p>
</div>

<div id="audit_rules_immutable_login_uids" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure immutable Audit login UIDs</h3>
<div>audit_rules_immutable_login_uids</div>
<h4>Description</h4>
<p>Configure kernel to prevent modification of login UIDs once they are set.
Changing login UIDs while this configuration is enforced requires special capabilities which
are not available to unprivileged users.
If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to make login UIDs
immutable:
<pre>--loginuid-immutable</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file in order to make login UIDs
immutable:
<pre>--loginuid-immutable</pre></p>
<h4>Rationale</h4>
<p>If modification of login UIDs is not prevented, they can be changed by unprivileged users and
make auditing complicated or impossible.</p>
</div>

<div id="audit_rules_kernel_module_loading" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Loading and Unloading</h3>
<div>audit_rules_kernel_module_loading</div>
<h4>Description</h4>
<p>To capture kernel module loading and unloading events, use following lines, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>
-a always,exit -F arch=<i>ARCH</i> -S init_module,finit_module,delete_module -F key=modules
</pre>

The place to add the lines depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the lines to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_kernel_module_loading_create" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Unloading - create_module</h3>
<div>audit_rules_kernel_module_loading_create</div>
<h4>Description</h4>
<p>
To capture kernel module loading and unloading events, use the following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S create_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_kernel_module_loading_delete" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Unloading - delete_module</h3>
<div>audit_rules_kernel_module_loading_delete</div>
<h4>Description</h4>
<p>
To capture kernel module loading and unloading events, use the following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S delete_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_kernel_module_loading_finit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Loading and Unloading - finit_module</h3>
<div>audit_rules_kernel_module_loading_finit</div>
<h4>Description</h4>
<p>
To capture kernel module loading and unloading events, use the following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S finit_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_kernel_module_loading_init" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Loading - init_module</h3>
<div>audit_rules_kernel_module_loading_init</div>
<h4>Description</h4>
<p>
To capture kernel module loading and unloading events, use the following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S init_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The addition of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_kernel_module_loading_query" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Kernel Module Loading and Unloading - query_module</h3>
<div>audit_rules_kernel_module_loading_query</div>
<h4>Description</h4>
<p>
To capture kernel module loading and unloading events, use the following line, setting ARCH to
either b32 for 32-bit system, or having two lines for both b32 and b64 in case your system is 64-bit:

<pre>-a always,exit -F arch=<i>ARCH</i> -S query_module -F auid>=1000 -F auid!=unset -F key=modules</pre>


Place to add the line depends on a way <tt>auditd</tt> daemon is configured. If it is configured
to use the <tt>augenrules</tt> program (the default), add the line to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility,
add the line to file <tt>/etc/audit/audit.rules</tt>.</p>
<h4>Rationale</h4>
<p>The addition/removal of kernel modules can be used to alter the behavior of
the kernel and potentially introduce malicious code into kernel space. It is important
to have an audit trail of modules that have been introduced into the kernel.</p>
</div>

<div id="audit_rules_login_events" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Logon and Logout Events</h3>
<div>audit_rules_login_events</div>
<h4>Description</h4>
<p>The audit system already collects login information for all users
and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins
-w <tt>$var_accounts_passwords_pam_faillock_dir</tt> -p wa -k logins
-w /var/log/lastlog -p wa -k logins</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for unattempted manual
edits of files involved in storing logon events:
<pre>-w /var/log/tallylog -p wa -k logins
-w <tt>$var_accounts_passwords_pam_faillock_dir</tt> -p wa -k logins
-w /var/log/lastlog -p wa -k logins</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_login_events_faillock" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Logon and Logout Events - faillock</h3>
<div>audit_rules_login_events_faillock</div>
<h4>Description</h4>
<p>The audit system already collects login information for all users
and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w <tt>$var_accounts_passwords_pam_faillock_dir</tt> -p wa -k logins</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w <tt>$var_accounts_passwords_pam_faillock_dir</tt> -p wa -k logins</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_login_events_faillog" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Logon and Logout Events - faillog</h3>
<div>audit_rules_login_events_faillog</div>
<h4>Description</h4>
<p>The audit system already collects login information for all users
and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/faillog -p wa -k logins</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/faillog -p wa -k logins</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_login_events_lastlog" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Logon and Logout Events - lastlog</h3>
<div>audit_rules_login_events_lastlog</div>
<h4>Description</h4>
<p>The audit system already collects login information for all users
and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/lastlog -p wa -k logins</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/lastlog -p wa -k logins</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_login_events_tallylog" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Logon and Logout Events - tallylog</h3>
<div>audit_rules_login_events_tallylog</div>
<h4>Description</h4>
<p>The audit system already collects login information for all users
and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/tallylog -p wa -k logins</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/tallylog -p wa -k logins</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_mac_modification" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Mandatory Access Controls</h3>
<div>audit_rules_mac_modification</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/apparmor/ -p wa -k MAC-policy</pre>
<pre>-w /etc/apparmor.d/ -p wa -k MAC-policy</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:

<pre>-w /etc/apparmor/ -p wa -k MAC-policy</pre>
<pre>-w /etc/apparmor.d/ -p wa -k MAC-policy</pre></p>
<h4>Rationale</h4>
<p>The system's mandatory access policy (SELinux or Apparmor) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.</p>
</div>

<div id="audit_rules_mac_modification_etc_apparmor" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Mandatory Access Controls (/etc/apparmor)</h3>
<div>audit_rules_mac_modification_etc_apparmor</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/apparmor/ -p wa -k MAC-policy</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/apparmor/ -p wa -k MAC-policy</pre></p>
<h4>Rationale</h4>
<p>The system's mandatory access policy (Apparmor) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.</p>
</div>

<div id="audit_rules_mac_modification_etc_apparmor_d" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Mandatory Access Controls (/etc/apparmor.d)</h3>
<div>audit_rules_mac_modification_etc_apparmor_d</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/apparmor.d/ -p wa -k MAC-policy</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/apparmor.d/ -p wa -k MAC-policy</pre></p>
<h4>Rationale</h4>
<p>The system's mandatory access policy (Apparmor) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.</p>
</div>

<div id="audit_rules_mac_modification_etc_selinux" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Mandatory Access Controls (/etc/selinux)</h3>
<div>audit_rules_mac_modification_etc_selinux</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/selinux/ -p wa -k MAC-policy</pre></p>
<h4>Rationale</h4>
<p>The system's mandatory access policy (SELinux) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.</p>
</div>

<div id="audit_rules_mac_modification_usr_share" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Mandatory Access Controls in usr/share</h3>
<div>audit_rules_mac_modification_usr_share</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /usr/share/selinux/ -p wa -k MAC-policy</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /usr/share/selinux/ -p wa -k MAC-policy</pre></p>
<h4>Rationale</h4>
<p>The system's mandatory access policy (SELinux) should not be
arbitrarily changed by anything other than administrator action. All changes to
MAC policy should be audited.</p>
</div>

<div id="audit_rules_media_export" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on Exporting to Media (successful)</h3>
<div>audit_rules_media_export</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect media exportation
events for all users and root. If the <tt>auditd</tt> daemon is configured to
use the <tt>augenrules</tt> program to read audit rules during daemon startup
(the default), add the following line to a file with suffix <tt>.rules</tt> in
the directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for
32-bit system, or having two lines for both b32 and b64 in case your
system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for
32-bit system, or having two lines for both b32 and b64 in case your
system is 64-bit:
<pre>-a always,exit -F arch=ARCH -S mount -F auid&gt;=1000 -F auid!=unset -F key=export</pre></p>
<h4>Rationale</h4>
<p>The unauthorized exportation of data to external media could result in an information leak
where classified information, Privacy Act information, and intellectual property could be lost. An audit
trail should be created each time a filesystem is mounted to help identify and guard against information
loss.</p>
</div>

<div id="audit_rules_networkconfig_modification" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Network Environment</h3>
<div>audit_rules_networkconfig_modification</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, setting ARCH to either b32 for
32-bit system, or having two lines for both b32 and b64 in case your system
is 64-bit:
<pre>-a always,exit -F arch=ARCH -S sethostname,setdomainname -F key=audit_rules_networkconfig_modification
-w /etc/issue -p wa -k audit_rules_networkconfig_modification
-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
-w /etc/hosts -p wa -k audit_rules_networkconfig_modification

-w /etc/netplan/ -p wa -k audit_rules_networkconfig_modification

-w /etc/networks -p wa -k audit_rules_networkconfig_modification
-w /etc/network/ -p wa -k audit_rules_networkconfig_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, setting ARCH to either b32 for
32-bit system, or having two lines for both b32 and b64 in case your system
is 64-bit:
<pre>-a always,exit -F arch=ARCH -S sethostname,setdomainname -F key=audit_rules_networkconfig_modification
-w /etc/issue -p wa -k audit_rules_networkconfig_modification
-w /etc/issue.net -p wa -k audit_rules_networkconfig_modification
-w /etc/hosts -p wa -k audit_rules_networkconfig_modification
-w /etc/networks -p wa -k audit_rules_networkconfig_modification
-w /etc/network/ -p wa -k audit_rules_networkconfig_modification</pre></p>
<h4>Rationale</h4>
<p>The network environment should not be modified by anything other
than administrator action. Any change to network parameters should be
audited.</p>
</div>

<div id="audit_rules_networkconfig_modification_hostname_file" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Network Environment - /etc/hostname</h3>
<div>audit_rules_networkconfig_modification_hostname_file</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/hostname -p wa -k audit_rules_networkconfig_modification_hostname_file</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/hostname -p wa -k audit_rules_networkconfig_modification_hostname_file</pre></p>
<h4>Rationale</h4>
<p>The network environment should not be modified by anything other
than administrator action. Any change to network parameters should be
audited.</p>
</div>

<div id="audit_rules_networkconfig_modification_network_scripts" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Network Environment - /etc/sysconfig/network-scripts</h3>
<div>audit_rules_networkconfig_modification_network_scripts</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/sysconfig/network-scripts -p wa -k audit_rules_networkconfig_modification_network_scripts</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/sysconfig/network-scripts -p wa -k audit_rules_networkconfig_modification_network_scripts</pre></p>
<h4>Rationale</h4>
<p>The network environment should not be modified by anything other
than administrator action. Any change to network parameters should be
audited.</p>
</div>

<div id="audit_rules_networkconfig_modification_networkmanager" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify the System's Network Environment - /etc/NetworkManager/</h3>
<div>audit_rules_networkconfig_modification_networkmanager</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/NetworkManager -p wa -k audit_rules_networkconfig_modification_networkmanager</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/NetworkManager -p wa -k audit_rules_networkconfig_modification_networkmanager</pre></p>
<h4>Rationale</h4>
<p>The network environment should not be modified by anything other
than administrator action. Any change to network parameters should be
audited.</p>
</div>

<div id="audit_rules_privileged_commands" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands</h3>
<div>audit_rules_privileged_commands</div>
<h4>Description</h4>
<p>The audit system should collect information about usage of privileged commands for all users.
These are commands with suid or sgid bits on and they are specially risky in local block
device partitions not mounted with noexec and nosuid options. Therefore, these partitions
should be first identified by the following command:
<pre>findmnt -n -l -k -it $(awk '/nodev/ { print $2 }' /proc/filesystems | paste -sd,) | grep -Pv "noexec|nosuid"</pre>

For all partitions listed by the previous command, it is necessary to search for
setuid / setgid programs using the following command:
<pre>$ sudo find <i>PARTITION</i> -xdev -perm /6000 -type f 2&gt;/dev/null</pre>

For each setuid / setgid program identified by the previous command, an audit rule must be
present in the appropriate place using the following line structure, setting ARCH to either b32 for 32-bit
system, or having two lines for both b32 and b64 in case your system is 64-bit:
<pre>-a always,exit -F arch=ARCH -F path=<i>PROG_PATH</i> -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt> program to read
audit rules during daemon startup, add the line to a file with suffix <tt>.rules</tt> in the
<tt>/etc/audit/rules.d</tt> directory, replacing the <i>PROG_PATH</i> part with the full path
of that setuid / setgid identified program.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility instead, add
the line to the <tt>/etc/audit/audit.rules</tt> file, also replacing the <i>PROG_PATH</i> part
with the full path of that setuid / setgid identified program.</p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by authorized users,
or by unauthorized external entities that have compromised system accounts, is a serious and
ongoing concern that can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify the
risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks, which attempt to subvert
their normal role of providing some necessary but limited capability. As such, motivation
exists to monitor these programs for unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_apparmor_parser" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run apparmor_parser</h3>
<div>audit_rules_privileged_commands_apparmor_parser</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/sbin/apparmor_parser -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.
Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_privileged_commands_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - at</h3>
<div>audit_rules_privileged_commands_at</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/at -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/at -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_chage" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - chage</h3>
<div>audit_rules_privileged_commands_chage</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chage -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_chfn" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - chfn</h3>
<div>audit_rules_privileged_commands_chfn</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chfn -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.

Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_privileged_commands_chsh" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - chsh</h3>
<div>audit_rules_privileged_commands_chsh</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/chsh -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_crontab" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - crontab</h3>
<div>audit_rules_privileged_commands_crontab</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/crontab -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_dbus_daemon_launch_helper" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - dbus helper</h3>
<div>audit_rules_privileged_commands_dbus_daemon_launch_helper</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/dbus-1/dbus-daemon-launch-helper-1 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/dbus-1/dbus-daemon-launch-helper-1 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_fdisk" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - fdisk</h3>
<div>audit_rules_privileged_commands_fdisk</div>
<h4>Description</h4>
<p>Configure the operating system to audit the execution of the partition
management program "fdisk".</p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security
and mission needs of the organization, it would be difficult to
establish, correlate, and investigate the events relating to an
incident or identify those responsible for one.
Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_privileged_commands_fusermount" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - fusermount</h3>
<div>audit_rules_privileged_commands_fusermount</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/fusermount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/fusermount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_fusermount3" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - fusermount3</h3>
<div>audit_rules_privileged_commands_fusermount3</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/fusermount3 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/fusermount3 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_gpasswd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - gpasswd</h3>
<div>audit_rules_privileged_commands_gpasswd</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/gpasswd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_grub2_set_bootflag" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - grub2_set_bootflag</h3>
<div>audit_rules_privileged_commands_grub2_set_bootflag</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/grub2-set-bootflag -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_insmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - insmod</h3>
<div>audit_rules_privileged_commands_insmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-w /sbin/insmod -p x -k modules</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_kmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - kmod</h3>
<div>audit_rules_privileged_commands_kmod</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/kmod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.

Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_privileged_commands_modprobe" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - modprobe</h3>
<div>audit_rules_privileged_commands_modprobe</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-w /sbin/modprobe -p x -k modules</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the following
form to <tt>/etc/audit/audit.rules</tt>:
<pre>-w /sbin/modprobe -p x -k modules</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_mount" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - mount</h3>
<div>audit_rules_privileged_commands_mount</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/mount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_mount_nfs" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - mount.nfs</h3>
<div>audit_rules_privileged_commands_mount_nfs</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/mount.mfs -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/mount.mfs -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_newgidmap" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - newgidmap</h3>
<div>audit_rules_privileged_commands_newgidmap</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newgidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_newgrp" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - newgrp</h3>
<div>audit_rules_privileged_commands_newgrp</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newgrp -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_newuidmap" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - newuidmap</h3>
<div>audit_rules_privileged_commands_newuidmap</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/newuidmap -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_pam_timestamp_check" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - pam_timestamp_check</h3>
<div>audit_rules_privileged_commands_pam_timestamp_check</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/pam_timestamp_check -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_passmass" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - passmass</h3>
<div>audit_rules_privileged_commands_passmass</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/passmass -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/passmass -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_passwd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - passwd</h3>
<div>audit_rules_privileged_commands_passwd</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/passwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_pkexec" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - pkexec</h3>
<div>audit_rules_privileged_commands_pkexec</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/pkexec -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/pkexec -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_polkit_helper" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - polkit helper</h3>
<div>audit_rules_privileged_commands_polkit_helper</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/lib/polkit-1/polkit-agent-helper-1 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/lib/polkit-1/polkit-agent-helper-1 -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_postdrop" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - postdrop</h3>
<div>audit_rules_privileged_commands_postdrop</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/postdrop -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_postqueue" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - postqueue</h3>
<div>audit_rules_privileged_commands_postqueue</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/postqueue -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_pt_chown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - pt_chown</h3>
<div>audit_rules_privileged_commands_pt_chown</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/pt_chown -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/pt_chown -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_rmmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - rmmod</h3>
<div>audit_rules_privileged_commands_rmmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect the execution of
privileged commands for all users and root. If the <tt>auditd</tt> daemon is
configured to use the <tt>augenrules</tt> program to read audit rules during
daemon startup (the default), add a line of the following form to a file with
suffix <tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-w /sbin/rmmod -p x -k modules</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sssd_krb5_child" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sssd_krb5_child</h3>
<div>audit_rules_privileged_commands_sssd_krb5_child</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/krb5_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/krb5_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sssd_ldap_child" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sssd_ldap_child</h3>
<div>audit_rules_privileged_commands_sssd_ldap_child</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/ldap_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/ldap_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sssd_proxy_child" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sssd_proxy_child</h3>
<div>audit_rules_privileged_commands_sssd_proxy_child</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/proxy_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/proxy_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sssd_selinux_child" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sssd_selinux_child</h3>
<div>audit_rules_privileged_commands_sssd_selinux_child</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/selinux_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/sssd/selinux_child -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_ssh_agent" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Any Attempts to Run ssh-agent</h3>
<div>audit_rules_privileged_commands_ssh_agent</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/ssh-agent -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Without generating audit records that are specific to the security and
mission needs of the organization, it would be difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.

Audit records can be generated from various components within the
information system (e.g., module or policy filter).</p>
</div>

<div id="audit_rules_privileged_commands_ssh_keysign" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - ssh-keysign</h3>
<div>audit_rules_privileged_commands_ssh_keysign</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/lib/openssh/ssh-keysign -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_su" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - su</h3>
<div>audit_rules_privileged_commands_su</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/su -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sudo" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sudo</h3>
<div>audit_rules_privileged_commands_sudo</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/sudo -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_sudoedit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - sudoedit</h3>
<div>audit_rules_privileged_commands_sudoedit</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/sudoedit -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_umount" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - umount</h3>
<div>audit_rules_privileged_commands_umount</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/umount -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_unix2_chkpwd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - unix2_chkpwd</h3>
<div>audit_rules_privileged_commands_unix2_chkpwd</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix2_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix2_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_unix_chkpwd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - unix_chkpwd</h3>
<div>audit_rules_privileged_commands_unix_chkpwd</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/sbin/unix_chkpwd -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_unix_update" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - unix_update</h3>
<div>audit_rules_privileged_commands_unix_update</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/unix_update -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_userhelper" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - userhelper</h3>
<div>audit_rules_privileged_commands_userhelper</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/userhelper -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_usermod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - usermod</h3>
<div>audit_rules_privileged_commands_usermod</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/usermod -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_usernetctl" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - usernetctl</h3>
<div>audit_rules_privileged_commands_usernetctl</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/sbin/usernetctl -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_utempter" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - utempter</h3>
<div>audit_rules_privileged_commands_utempter</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/libexec/utempter -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/libexec/utempter -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_privileged_commands_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Information on the Use of Privileged Commands - write</h3>
<div>audit_rules_privileged_commands_write</div>
<h4>Description</h4>
<p>


At a minimum, the audit system should collect the execution of privileged
commands for all users and root.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add
a line of the following form to a file with suffix <tt>.rules</tt>
in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F path=/usr/bin/write -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add a line of the
following form to <tt>/etc/audit/audit.rules</tt>:
<pre>-a always,exit -F path=/usr/bin/write -F perm=x -F auid&gt;=1000 -F auid!=unset -F key=privileged</pre></p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have compromised system accounts,
is a serious and ongoing concern and can have significant adverse impacts on organizations.
Auditing the use of privileged functions is one way to detect such misuse and identify
the risk from insider and advanced persistent threats.
<br /><br />
Privileged programs are subject to escalation-of-privilege attacks,
which attempt to subvert their normal role of providing some necessary but
limited capability. As such, motivation exists to monitor these programs for
unusual activity.</p>
</div>

<div id="audit_rules_session_events" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Process and Session Initiation Information</h3>
<div>audit_rules_session_events</div>
<h4>Description</h4>
<p>The audit system already collects process information for all
users and root. If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> in order to watch for attempted manual
edits of files involved in storing such process information:
<pre>-w /var/run/utmp -p wa -k session
-w /var/log/btmp -p wa -k session
-w /var/log/wtmp -p wa -k session</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file in order to watch for attempted manual
edits of files involved in storing such process information:
<pre>-w /var/run/utmp -p wa -k session
-w /var/log/btmp -p wa -k session
-w /var/log/wtmp -p wa -k session</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_session_events_btmp" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Process and Session Initiation Information btmp</h3>
<div>audit_rules_session_events_btmp</div>
<h4>Description</h4>
<p>The audit system already collects process information for all
users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/btmp -p wa -k session</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/btmp -p wa -k session</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_session_events_utmp" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Process and Session Initiation Information utmp</h3>
<div>audit_rules_session_events_utmp</div>
<h4>Description</h4>
<p>The audit system already collects process information for all
users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/run/utmp -p wa -k session</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/run/utmp -p wa -k session</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_session_events_wtmp" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Process and Session Initiation Information wtmp</h3>
<div>audit_rules_session_events_wtmp</div>
<h4>Description</h4>
<p>The audit system already collects process information for all
users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/wtmp -p wa -k session</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/wtmp -p wa -k session</pre></p>
<h4>Rationale</h4>
<p>Manual editing of these files may indicate nefarious activity, such
as an attacker attempting to remove evidence of an intrusion.</p>
</div>

<div id="audit_rules_successful_file_modification_chmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - chmod</h3>
<div>audit_rules_successful_file_modification_chmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S chmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_chown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Ownership Changes to Files - chown</h3>
<div>audit_rules_successful_file_modification_chown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file ownership changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S chown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S chown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File ownership attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - creat</h3>
<div>audit_rules_successful_file_modification_creat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S creat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fchmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - fchmod</h3>
<div>audit_rules_successful_file_modification_fchmod</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fchmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmod -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fchmodat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - fchmodat</h3>
<div>audit_rules_successful_file_modification_fchmodat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fchmodat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmodat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchmodat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmodat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Ownership Changes to Files - fchown</h3>
<div>audit_rules_successful_file_modification_fchown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file ownership changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File ownership attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fchownat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Ownership Changes to Files - fchownat</h3>
<div>audit_rules_successful_file_modification_fchownat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file ownership changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchownat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File ownership attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - fremovexattr</h3>
<div>audit_rules_successful_file_modification_fremovexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_fsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - fsetxattr</h3>
<div>audit_rules_successful_file_modification_fsetxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S fsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S fsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_ftruncate" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - ftruncate</h3>
<div>audit_rules_successful_file_modification_ftruncate</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S ftruncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_lchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Ownership Changes to Files - lchown</h3>
<div>audit_rules_successful_file_modification_lchown</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file ownership changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S lchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lchown -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File ownership attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_lremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - lremovexattr</h3>
<div>audit_rules_successful_file_modification_lremovexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S lremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_lsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - lsetxattr</h3>
<div>audit_rules_successful_file_modification_lsetxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S lsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S lsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - open</h3>
<div>audit_rules_successful_file_modification_open</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S open -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S open -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S open -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - open_by_handle_at</h3>
<div>audit_rules_successful_file_modification_open_by_handle_at</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S open_by_handle_at -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open_by_handle_at_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - open_by_handle_at O_CREAT</h3>
<div>audit_rules_successful_file_modification_open_by_handle_at_o_creat</div>
<h4>Description</h4>
<p>The <tt>open_by_handle_at</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following audit rules will assure that successful attempts to create a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open_by_handle_at_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - open_by_handle_at O_TRUNC_WRITE</h3>
<div>audit_rules_successful_file_modification_open_by_handle_at_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed file access records for
all users and root. The <tt>open_by_handle_at</tt> syscall can be used to modify
files if called for write operation with the O_TRUNC_WRITE flag.

The following audit rules will assure that successful attempts to create a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - open O_CREAT</h3>
<div>audit_rules_successful_file_modification_open_o_creat</div>
<h4>Description</h4>
<p>The <tt>open</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following audit rules will assure that successful attempts to create a
file via <tt>open</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S open -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_open_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - open O_TRUNC_WRITE</h3>
<div>audit_rules_successful_file_modification_open_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed file access records for
all users and root. The <tt>open</tt> syscall can be used to modify
files if called for write operation with the O_TRUNC_WRITE flag.

The following audit rules will assure that successful attempts to create a
file via <tt>open</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S open -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - openat</h3>
<div>audit_rules_successful_file_modification_openat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S openat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S openat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S openat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_openat_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - openat O_CREAT</h3>
<div>audit_rules_successful_file_modification_openat_o_creat</div>
<h4>Description</h4>
<p>The <tt>openat</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following audit rules will assure that successful attempts to create a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-create
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_openat_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Creation Attempts to Files - openat O_TRUNC_WRITE</h3>
<div>audit_rules_successful_file_modification_openat_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed file access records for
all users and root. The <tt>openat</tt> syscall can be used to modify
files if called for write operation with the O_TRUNC_WRITE flag.

The following audit rules will assure that successful attempts to create a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.

<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F success=1 -F auid>=1000 -F auid!=unset -F key=successful-modification
</pre></p>
<h4>Rationale</h4>
<p>Successful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_removexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - removexattr</h3>
<div>audit_rules_successful_file_modification_removexattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S removexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S removexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S removexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S removexattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File permission changes could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_rename" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Delete Attempts to Files - rename</h3>
<div>audit_rules_successful_file_modification_rename</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file
deletion for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S rename -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S rename -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S rename -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S rename -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre></p>
<h4>Rationale</h4>
<p>File deletion attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_renameat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Delete Attempts to Files - renameat</h3>
<div>audit_rules_successful_file_modification_renameat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file
deletion for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S renameat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre></p>
<h4>Rationale</h4>
<p>File deletion attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_setxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Permission Changes to Files - setxattr</h3>
<div>audit_rules_successful_file_modification_setxattr</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file permission changes
for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S setxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S setxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S setxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S setxattr -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-perm-change</pre></p>
<h4>Rationale</h4>
<p>File deletion attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_truncate" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Access Attempts to Files - truncate</h3>
<div>audit_rules_successful_file_modification_truncate</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S truncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S truncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S truncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S truncate -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-access</pre></p>
<h4>Rationale</h4>
<p>File access attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_unlink" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Delete Attempts to Files - unlink</h3>
<div>audit_rules_successful_file_modification_unlink</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file
deletion for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S unlink -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S unlink -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S unlink -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S unlink -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre></p>
<h4>Rationale</h4>
<p>File deletion attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_successful_file_modification_unlinkat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Successful Delete Attempts to Files - unlinkat</h3>
<div>audit_rules_successful_file_modification_unlinkat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect file
deletion for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:

<pre>-a always,exit -F arch=b32 -S unlinkat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S unlinkat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S unlinkat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S unlinkat -F success=1 -F auid&gt;=1000 -F auid!=unset -F key=successful-delete</pre></p>
<h4>Rationale</h4>
<p>File deletion attempts could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_sudoers" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects System Administrator Actions - /etc/sudoers</h3>
<div>audit_rules_sudoers</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect administrator actions
for all users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/sudoers -p wa -k actions</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/sudoers -p wa -k actions</pre></p>
<h4>Rationale</h4>
<p>The actions taken by system administrators should be audited to keep a record
of what was executed on the system, as well as, for accountability purposes.
Editing the sudoers file may be sign of an attacker trying to
establish persistent methods to a system, auditing the editing of the sudoers
files mitigates this risk.</p>
</div>

<div id="audit_rules_sudoers_d" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects System Administrator Actions - /etc/sudoers.d/</h3>
<div>audit_rules_sudoers_d</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect administrator actions
for all users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/sudoers.d/ -p wa -k actions</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/sudoers.d/ -p wa -k actions</pre></p>
<h4>Rationale</h4>
<p>The actions taken by system administrators should be audited to keep a record
of what was executed on the system, as well as, for accountability purposes.
Editing the sudoers file may be sign of an attacker trying to
establish persistent methods to a system, auditing the editing of the sudoers
files mitigates this risk.</p>
</div>

<div id="audit_rules_suid_privilege_function" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events When Privileged Executables Are Run</h3>
<div>audit_rules_suid_privilege_function</div>
<h4>Description</h4>
<p>Verify the system generates an audit record when privileged functions are executed.

If audit is using the "auditctl" tool to load the rules, run the following command:

<pre>$ sudo grep execve /etc/audit/audit.rules</pre>

If audit is using the "augenrules" tool to load the rules, run the following command:

<pre>$ sudo grep -r execve /etc/audit/rules.d</pre>


<pre>-a always,exit -F arch=b32 -S execve -C uid!=euid -F euid=0 -k setuid</pre>
<pre>-a always,exit -F arch=b64 -S execve -C uid!=euid -F euid=0 -k setuid</pre>
<pre>-a always,exit -F arch=b32 -S execve -C gid!=egid -F egid=0 -k setgid</pre>
<pre>-a always,exit -F arch=b64 -S execve -C gid!=egid -F egid=0 -k setgid</pre>


If both the "b32" and "b64" audit rules for "SUID" files are not defined, this is a finding.
If both the "b32" and "b64" audit rules for "SGID" files are not defined, this is a finding.</p>
<h4>Rationale</h4>
<p>Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have
compromised information system accounts, is a serious and ongoing concern
and can have significant adverse impacts on organizations. Auditing the use
of privileged functions is one way to detect such misuse and identify the
risk from insider threats and the advanced persistent threat.</p>
</div>

<div id="audit_rules_suid_auid_privilege_function" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events When Executables Are Run As Another User</h3>
<div>audit_rules_suid_auid_privilege_function</div>
<h4>Description</h4>
<p>Verify the system generates an audit record when actions are run as another user.
sudo provides users with temporary elevated privileges to perform operations, either as the superuser or another user.

If audit is using the "auditctl" tool to load the rules, run the following command:

<pre>$ sudo grep execve /etc/audit/audit.rules</pre>

If audit is using the "augenrules" tool to load the rules, run the following command:

<pre>$ sudo grep -r execve /etc/audit/rules.d</pre>
<pre>-a always,exit -F arch=b32 -S execve -C euid!=uid -F auid!=unset -k user_emulation</pre>
<pre>-a always,exit -F arch=b64  S execve -C euid!=uid -F auid!=unset -k user_emulation</pre>

If both the "b32" and "b64" audit rules for "SUID" files are not defined, this is a finding.</p>
<h4>Rationale</h4>
<p>Creating an audit log of users with temporary elevated privileges and the
operation(s) they performed is essential to reporting. Administrators will
want to correlate the events written to the audit trail with the records
written to sudo's logfile to verify if unauthorized commands have
been executed.
Misuse of privileged functions, either intentionally or unintentionally by
authorized users, or by unauthorized external entities that have
compromised information system accounts, is a serious and ongoing concern
and can have significant adverse impacts on organizations. Auditing the use
of privileged functions is one way to detect such misuse and identify the
risk from insider threats and the advanced persistent threat.</p>
</div>

<div id="audit_rules_sysadmin_actions" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects System Administrator Actions</h3>
<div>audit_rules_sysadmin_actions</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/sudoers -p wa -k actions</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/sudoers -p wa -k actions</pre>






If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/sudoers.d/ -p wa -k actions</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/sudoers.d/ -p wa -k actions</pre></p>
<h4>Rationale</h4>
<p>The actions taken by system administrators should be audited to keep a record
of what was executed on the system, as well as, for accountability purposes.</p>
</div>

<div id="audit_rules_system_shutdown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Shutdown System When Auditing Failures Occur</h3>
<div>audit_rules_system_shutdown</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to to the bottom of a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-f <tt>$var_audit_failure_mode</tt></pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to the
bottom of the <tt>/etc/audit/audit.rules</tt> file:
<pre>-f <tt>$var_audit_failure_mode</tt></pre></p>
<h4>Rationale</h4>
<p>It is critical for the appropriate personnel to be aware if a system
is at risk of failing to process audit logs as required. Without this
notification, the security personnel may be unaware of an impending failure of
the audit capability, and system operation may be adversely affected.
<br /><br />
Audit processing failures include software/hardware errors, failures in the
audit capturing mechanisms, and audit storage capacity being reached or
exceeded.</p>
</div>

<div id="audit_rules_time_adjtimex" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record attempts to alter time through adjtimex</h3>
<div>audit_rules_time_adjtimex</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S adjtimex -F key=audit_time_rules</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S adjtimex -F key=audit_time_rules</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S adjtimex -F key=audit_time_rules</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S adjtimex -F key=audit_time_rules</pre>
The -k option allows for the specification of a key in string form that can be
used for better reporting capability through ausearch and aureport. Multiple
system calls can be defined on the same line to save space if desired, but is
not required. See an example of multiple combined syscalls:
<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre></p>
<h4>Rationale</h4>
<p>Arbitrary changes to the system time can be used to obfuscate
nefarious activities in log files, as well as to confuse network services that
are highly dependent upon an accurate system time (such as sshd). All changes
to the system time should be audited.</p>
</div>

<div id="audit_rules_time_clock_settime" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Time Through clock_settime</h3>
<div>audit_rules_time_clock_settime</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S clock_settime -F a0=0x0 -F key=time-change</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S clock_settime -F a0=0x0 -F key=time-change</pre>
The -k option allows for the specification of a key in string form that can
be used for better reporting capability through ausearch and aureport.
Multiple system calls can be defined on the same line to save space if
desired, but is not required. See an example of multiple combined syscalls:
<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre></p>
<h4>Rationale</h4>
<p>Arbitrary changes to the system time can be used to obfuscate
nefarious activities in log files, as well as to confuse network services that
are highly dependent upon an accurate system time (such as sshd). All changes
to the system time should be audited.</p>
</div>

<div id="audit_rules_time_settimeofday" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record attempts to alter time through settimeofday</h3>
<div>audit_rules_time_settimeofday</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S settimeofday -F key=audit_time_rules</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S settimeofday -F key=audit_time_rules</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S settimeofday -F key=audit_time_rules</pre>
If the system is 64 bit then also add the following line:
<pre>-a always,exit -F arch=b64 -S settimeofday -F key=audit_time_rules</pre>
The -k option allows for the specification of a key in string form that can be
used for better reporting capability through ausearch and aureport. Multiple
system calls can be defined on the same line to save space if desired, but is
not required. See an example of multiple combined syscalls:
<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre></p>
<h4>Rationale</h4>
<p>Arbitrary changes to the system time can be used to obfuscate
nefarious activities in log files, as well as to confuse network services that
are highly dependent upon an accurate system time (such as sshd). All changes
to the system time should be audited.</p>
</div>

<div id="audit_rules_time_stime" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter Time Through stime</h3>
<div>audit_rules_time_stime</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following line to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt> for both 32 bit and 64 bit systems:
<pre>-a always,exit -F arch=b32 -S stime -F key=audit_time_rules</pre>
Since the 64 bit version of the "stime" system call is not defined in the audit
lookup table, the corresponding "-F arch=b64" form of this rule is not expected
to be defined on 64 bit systems (the aforementioned "-F arch=b32" stime rule
form itself is sufficient for both 32 bit and 64 bit systems). If the
<tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt> utility to
read audit rules during daemon startup, add the following line to
<tt>/etc/audit/audit.rules</tt> file for both 32 bit and 64 bit systems:
<pre>-a always,exit -F arch=b32 -S stime -F key=audit_time_rules</pre>
Since the 64 bit version of the "stime" system call is not defined in the audit
lookup table, the corresponding "-F arch=b64" form of this rule is not expected
to be defined on 64 bit systems (the aforementioned "-F arch=b32" stime rule
form itself is sufficient for both 32 bit and 64 bit systems). The -k option
allows for the specification of a key in string form that can be used for
better reporting capability through ausearch and aureport. Multiple system
calls can be defined on the same line to save space if desired, but is not
required. See an example of multiple combined system calls:
<pre>-a always,exit -F arch=b64 -S adjtimex,settimeofday -F key=audit_time_rules</pre></p>
<h4>Rationale</h4>
<p>Arbitrary changes to the system time can be used to obfuscate
nefarious activities in log files, as well as to confuse network services that
are highly dependent upon an accurate system time (such as sshd). All changes
to the system time should be audited.</p>
</div>

<div id="audit_rules_time_watch_localtime" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to Alter the localtime File</h3>
<div>audit_rules_time_watch_localtime</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/localtime -p wa -k audit_time_rules</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/localtime -p wa -k audit_time_rules</pre></p>
<h4>Rationale</h4>
<p>Arbitrary changes to the system time can be used to obfuscate
nefarious activities in log files, as well as to confuse network services that
are highly dependent upon an accurate system time (such as sshd). All changes
to the system time should be audited.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Unauthorized Access Attempts to Files (unsuccessful)</h3>
<div>audit_rules_unsuccessful_file_modification</div>
<h4>Description</h4>
<p>At a minimum the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat,open,openat,open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_chmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - chmod</h3>
<div>audit_rules_unsuccessful_file_modification_chmod</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S chmod -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S chmod -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chmod -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S chmod -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_chown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Ownership Changes to Files - chown</h3>
<div>audit_rules_unsuccessful_file_modification_chown</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file ownership change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S chown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S chown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S chown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S chown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change ownership of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - creat</h3>
<div>audit_rules_unsuccessful_file_modification_creat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S creat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S creat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fchmod" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - fchmod</h3>
<div>audit_rules_unsuccessful_file_modification_fchmod</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fchmod -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fchmod -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmod -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fchmod -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fchmodat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - fchmodat</h3>
<div>audit_rules_unsuccessful_file_modification_fchmodat</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fchmodat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fchmodat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchmodat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fchmodat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Ownership Changes to Files - fchown</h3>
<div>audit_rules_unsuccessful_file_modification_fchown</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file ownership change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fchown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fchown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fchown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change ownership of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fchownat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Ownership Changes to Files - fchownat</h3>
<div>audit_rules_unsuccessful_file_modification_fchownat</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file ownership change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fchownat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fchownat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change ownership of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - fremovexattr</h3>
<div>audit_rules_unsuccessful_file_modification_fremovexattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_fsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - fsetxattr</h3>
<div>audit_rules_unsuccessful_file_modification_fsetxattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S fsetxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S fsetxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S fsetxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S fsetxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_ftruncate" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - ftruncate</h3>
<div>audit_rules_unsuccessful_file_modification_ftruncate</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_lchown" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Ownership Changes to Files - lchown</h3>
<div>audit_rules_unsuccessful_file_modification_lchown</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file ownership change
attempts for all users and root.

If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.

<pre>-a always,exit -F arch=b32 -S lchown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S lchown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>

If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lchown -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S lchown -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change ownership of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_lremovexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - lremovexattr</h3>
<div>audit_rules_unsuccessful_file_modification_lremovexattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S lremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S lremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lremovexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S lremovexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_lsetxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - lsetxattr</h3>
<div>audit_rules_unsuccessful_file_modification_lsetxattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S lsetxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S lsetxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S lsetxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S lsetxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - open</h3>
<div>audit_rules_unsuccessful_file_modification_open</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_by_handle_at" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - open_by_handle_at</h3>
<div>audit_rules_unsuccessful_file_modification_open_by_handle_at</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S open_by_handle_at,truncate,ftruncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_by_handle_at_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Creation Attempts to Files - open_by_handle_at O_CREAT</h3>
<div>audit_rules_unsuccessful_file_modification_open_by_handle_at_o_creat</div>
<h4>Description</h4>
<p>The audit system should collect unauthorized file accesses for
all users and root. The <tt>open_by_handle_at</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will assure that unsuccessful attempts to create a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_by_handle_at_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Modification Attempts to Files - open_by_handle_at O_TRUNC_WRITE</h3>
<div>audit_rules_unsuccessful_file_modification_open_by_handle_at_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>open_by_handle_at</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will assure that unsuccessful attempts to modify a
file via <tt>open_by_handle_at</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_by_handle_at_rule_order" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Unauthorized Access Attempts To open_by_handle_at Are Ordered Correctly</h3>
<div>audit_rules_unsuccessful_file_modification_open_by_handle_at_rule_order</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>open_by_handle_at</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>open_by_handle_at</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open_by_handle_at -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre></p>
<h4>Rationale</h4>
<p>The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Creation Attempts to Files - open O_CREAT</h3>
<div>audit_rules_unsuccessful_file_modification_open_o_creat</div>
<h4>Description</h4>
<p>The audit system should collect unauthorized file accesses for
all users and root. The <tt>open</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will assure that unsuccessful attempts to create a
file via <tt>open</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Modification Attempts to Files - open O_TRUNC_WRITE</h3>
<div>audit_rules_unsuccessful_file_modification_open_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>open</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.
The following auidt rules will assure that unsuccessful attempts to modify a
file via <tt>open</tt> syscall are collected.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_open_rule_order" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Rules For Unauthorized Attempts To open Are Ordered Correctly</h3>
<div>audit_rules_unsuccessful_file_modification_open_rule_order</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>open</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>open</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S open -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S open -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F a1&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S open -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S open -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre></p>
<h4>Rationale</h4>
<p>The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_openat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - openat</h3>
<div>audit_rules_unsuccessful_file_modification_openat</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_openat_o_creat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Creation Attempts to Files - openat O_CREAT</h3>
<div>audit_rules_unsuccessful_file_modification_openat_o_creat</div>
<h4>Description</h4>
<p>The audit system should collect unauthorized file accesses for
all users and root. The <tt>openat</tt> syscall can be used to create new files
when O_CREAT flag is specified.

The following auidt rules will assure that unsuccessful attempts to create a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_openat_o_trunc_write" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Modification Attempts to Files - openat O_TRUNC_WRITE</h3>
<div>audit_rules_unsuccessful_file_modification_openat_o_trunc_write</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file accesses for
all users and root. The <tt>openat</tt> syscall can be used to modify files
if called for write operation of with O_TRUNC_WRITE flag.

The following auidt rules will assure that unsuccessful attempts to modify a
file via <tt>openat</tt> syscall are collected.

If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rules below to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rules below to
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_openat_rule_order" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Rules For Unauthorized Attempts To openat Are Ordered Correctly</h3>
<div>audit_rules_unsuccessful_file_modification_openat_rule_order</div>
<h4>Description</h4>
<p>The audit system should collect detailed unauthorized file
accesses for all users and root.
To correctly identify unsuccessful creation, unsuccessful modification and unsuccessful access
of files via <tt>openat</tt> syscall the audit rules collecting these events need to be in certain order.
The more specific rules need to come before the less specific rules. The reason for that is that more
specific rules cover a subset of events covered in the less specific rules, thus, they need to come
before to not be overshadowed by less specific rules, which match a bigger set of events.
Make sure that rules for unsuccessful calls of <tt>openat</tt> syscall are in the order shown below.
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), check the order of
rules below in a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, check the order of rules below in
<tt>/etc/audit/audit.rules</tt> file.
<pre>
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b32 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b32 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;0100 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-create
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F a2&amp;01003 -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-modification
-a always,exit -F arch=b64 -S openat -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
-a always,exit -F arch=b64 -S openat -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-access
</pre></p>
<h4>Rationale</h4>
<p>The more specific rules cover a subset of events covered by the less specific rules.
By ordering them from more specific to less specific, it is assured that the less specific
rule will not catch events better recorded by the more specific rule.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_removexattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - removexattr</h3>
<div>audit_rules_unsuccessful_file_modification_removexattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S removexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S removexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S removexattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S removexattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_rename" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Delete Attempts to Files - rename</h3>
<div>audit_rules_unsuccessful_file_modification_rename</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S rename -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S rename -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_renameat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Delete Attempts to Files - renameat</h3>
<div>audit_rules_unsuccessful_file_modification_renameat</div>
<h4>Description</h4>
<p>
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>
If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S renameat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S renameat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_renameat2" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Delete Attempts to Files - renameat2</h3>
<div>audit_rules_unsuccessful_file_modification_renameat2</div>
<h4>Description</h4>
<p>The operating system must generate audit records for all uses of the <tt>renameat2</tt> system call.
Without generating audit records specific to the security and mission needs of the organization, it would be 
difficult to establish, correlate, and investigate the events relating to an incident or identify those responsible for one.
Audit records can be generated from various components within the information system (e.g., module or policy filter).
Add or update the following lines to <tt>/etc/audit/rules.d/audit.rules</tt> to configure the operating system to generate 
an audit record for all uses of the <tt>renameat2</tt> system call:  
<pre>
-a always,exit -F arch=b32 -S renameat2 -F auid>=1000 -F auid!=-1 -k perm_mod
-a always,exit -F arch=b64 -S renameat2 -F auid>=1000 -F auid!=-1 -k perm_mod</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_setxattr" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Permission Changes to Files - setxattr</h3>
<div>audit_rules_unsuccessful_file_modification_setxattr</div>
<h4>Description</h4>
<p>The audit system should collect unsuccessful file permission change
attempts for all users and root.
If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S setxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b32 -S setxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre>
If the system is 64 bit then also add the following lines:
<pre>-a always,exit -F arch=b64 -S setxattr -F exit=-EACCES -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change
-a always,exit -F arch=b64 -S setxattr -F exit=-EPERM -F auid>=1000 -F auid!=unset -F key=unsuccesful-perm-change</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to change permissions of files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_truncate" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Access Attempts to Files - truncate</h3>
<div>audit_rules_unsuccessful_file_modification_truncate</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect unauthorized file
accesses for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file:
<pre>-a always,exit -F arch=b32 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b32 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S truncate -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=access
-a always,exit -F arch=b64 -S truncate -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=access</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to access files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_unlink" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Delete Attempts to Files - unlink</h3>
<div>audit_rules_unsuccessful_file_modification_unlink</div>
<h4>Description</h4>
<p>
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlink -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlink -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_unsuccessful_file_modification_unlinkat" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Unsuccessful Delete Attempts to Files - unlinkat</h3>
<div>audit_rules_unsuccessful_file_modification_unlinkat</div>
<h4>Description</h4>
<p>
The audit system should collect unsuccessful file deletion
attempts for all users and root. If the <tt>auditd</tt> daemon is configured
to use the <tt>augenrules</tt> program to read audit rules during daemon
startup (the default), add the following lines to a file with suffix
<tt>.rules</tt> in the directory <tt>/etc/audit/rules.d</tt>.

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file.
<pre>-a always,exit -F arch=b32 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b32 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre>

If the system is 64 bit then also add the following lines:
<pre>
-a always,exit -F arch=b64 -S unlinkat -F exit=-EACCES -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete
-a always,exit -F arch=b64 -S unlinkat -F exit=-EPERM -F auid&gt;=1000 -F auid!=unset -F key=unsuccessful-delete</pre></p>
<h4>Rationale</h4>
<p>Unsuccessful attempts to delete files could be an indicator of malicious activity on a system. Auditing
these events could serve as evidence of potential system compromise.</p>
</div>

<div id="audit_rules_usergroup_modification" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information</h3>
<div>audit_rules_usergroup_modification</div>
<h4>Description</h4>
<p>If the <tt>auditd</tt> daemon is configured to use the
<tt>augenrules</tt> program to read audit rules during daemon startup (the
default), add the following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>, in order to capture events that modify
account changes:
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification
-w /etc/passwd -p wa -k audit_rules_usergroup_modification
-w /etc/gshadow -p wa -k audit_rules_usergroup_modification
-w /etc/shadow -p wa -k audit_rules_usergroup_modification
-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>
<br />
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt> file, in order to capture events that modify
account changes:
<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification
-w /etc/passwd -p wa -k audit_rules_usergroup_modification
-w /etc/gshadow -p wa -k audit_rules_usergroup_modification
-w /etc/shadow -p wa -k audit_rules_usergroup_modification
-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_group" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/group</h3>
<div>audit_rules_usergroup_modification_group</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/group -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_gshadow" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/gshadow</h3>
<div>audit_rules_usergroup_modification_gshadow</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/gshadow -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_opasswd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/security/opasswd</h3>
<div>audit_rules_usergroup_modification_opasswd</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/security/opasswd -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_passwd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/passwd</h3>
<div>audit_rules_usergroup_modification_passwd</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/passwd -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_shadow" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/shadow</h3>
<div>audit_rules_usergroup_modification_shadow</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/shadow -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>

<div id="audit_rules_usergroup_modification_nsswitch_conf" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/nsswitch.conf</h3>
<div>audit_rules_usergroup_modification_nsswitch_conf</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/nsswitch.conf -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/nsswitch.conf -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>The nsswitch file defines how the system uses various databases and name
resolution mechanisms. Any unexpected changes to nsswitch configuration
should be investigated.</p>
</div>

<div id="audit_rules_usergroup_modification_pam_conf" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/pam.conf</h3>
<div>audit_rules_usergroup_modification_pam_conf</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/pam.conf -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/pam.conf -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>The PAM configuration file defines the authentication mechanism
used by PAM-aware applications. Any unexpected changes to PAM configuration
should be investigated.</p>
</div>

<div id="audit_rules_usergroup_modification_pamd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Events that Modify User/Group Information - /etc/pam.d/</h3>
<div>audit_rules_usergroup_modification_pamd</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/pam.d/ -p wa -k audit_rules_usergroup_modification</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/pam.d/ -p wa -k audit_rules_usergroup_modification</pre></p>
<h4>Rationale</h4>
<p>The PAM configuration files in /etc/pam.d define the authentication mechanism
used by PAM-aware applications. Any unexpected changes to PAM configuration
should be investigated.</p>
</div>

<div id="audit_rules_var_log_journal" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects records for events that affect "/var/log/journal"</h3>
<div>audit_rules_var_log_journal</div>
<h4>Description</h4>
<p>Auditing the systemd journal files provides logging that can be used for
forensic purposes. Verify the system generates audit records for all events
that affect "/var/log/journal" by using the following command:

<pre>
$ sudo auditctl -l | grep journal
-w /var/log/journal/ -p wa -k systemd_journal
</pre>

If the command does not return a line that matches the example or the line
is commented out, this is a finding.

Note: The "-k" value is arbitrary and can be different from the example
output above.





If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/journal -p wa -k systemd_journal</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/journal -p wa -k systemd_journal</pre></p>
<h4>Rationale</h4>
<p>Once an attacker establishes access to a system, the attacker often attempts
to create a persistent method of reestablishing access. One way to accomplish
this is for the attacker to modify system level binaries and their operation.
Auditing the systemd journal files provides logging that can be used for
forensic purposes.</p>
</div>

<div id="audit_sudo_log_events" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Attempts to perform maintenance activities</h3>
<div>audit_sudo_log_events</div>
<h4>Description</h4>
<p>The Ubuntu 24.04 operating system must generate audit records for
privileged activities, nonlocal maintenance, diagnostic sessions and
other system-level access.

Verify the operating system audits activities performed during nonlocal
maintenance and diagnostic sessions. Run the following command:
<pre>$ sudo auditctl -l | grep sudo.log
-w /var/log/sudo.log -p wa -k maintenance</pre>





If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/log/sudo.log -p wa -k maintenance</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/log/sudo.log -p wa -k maintenance</pre></p>
<h4>Rationale</h4>
<p>If events associated with nonlocal administrative access or diagnostic
sessions are not logged, a major tool for assessing and investigating
attacks would not be available.
This requirement addresses auditing-related issues associated with
maintenance tools used specifically for diagnostic and repair actions
on organizational information systems.
Nonlocal maintenance and diagnostic activities are those activities
conducted by individuals communicating through a network, either an
external network (e.g., the internet) or an internal network. Local
maintenance and diagnostic activities are those activities carried
out by individuals physically present at the information system or
information system component and not communicating across a network
connection.
This requirement applies to hardware/software diagnostic test
equipment or tools. This requirement does not cover hardware/software
components that may support information system maintenance, yet are a
part of the system, for example, the software implementing "ping,"
"ls," "ipconfig," or the hardware and software implementing the
monitoring port of an Ethernet switch.</p>
</div>

<div id="auditd_audispd_configure_remote_server" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure audispd Plugin To Send Logs To Remote Server</h3>
<div>auditd_audispd_configure_remote_server</div>
<h4>Description</h4>
<p>Configure the audispd plugin to off-load audit records onto a different
system or media from the system being audited.

First, set the <tt>active</tt> option in
<pre>/etc/audisp/plugins.d/au-remote.conf</pre>

Set the <tt>remote_server</tt> option in <pre>/etc/audit/audisp-remote.conf</pre>
with an IP address or hostname of the system that the audispd plugin should
send audit records to. For example
<pre>remote_server = <i><tt>$var_audispd_remote_server</tt></i></pre></p>
<h4>Rationale</h4>
<p>Information stored in one location is vulnerable to accidental or incidental
deletion or alteration.Off-loading is a common process in information systems
with limited audit storage capacity.</p>
</div>

<div id="auditd_audispd_configure_sufficiently_large_partition" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure a Sufficiently Large Partition for Audit Logs</h3>
<div>auditd_audispd_configure_sufficiently_large_partition</div>
<h4>Description</h4>
<p>The Ubuntu 24.04 operating system must allocate audit record storage
capacity to store at least one weeks worth of audit records when audit
records are not immediately sent to a central audit record storage
facility.

The partition size needed to capture a week's worth of audit records is
based on the activity level of the system and the total storage capacity
available.


Determine which partition the audit records are being written to with the
following command:

<pre>$ sudo grep log_file /etc/audit/auditd.conf
log_file = /var/log/audit/audit.log</pre>

Check the size of the partition that audit records are written to with the
following command:

<pre>$ sudo df -h /var/log/audit/
/dev/sda2 24G 10.4G 13.6G 43% /var/log/audit</pre></p>
<h4>Rationale</h4>
<p>Information stored in one location is vulnerable to accidental or incidental
deletion or alteration. Off-loading is a common process in information
systems with limited audit storage capacity.</p>
</div>

<div id="auditd_audispd_disk_full_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure audispd's Plugin disk_full_action When Disk Is Full</h3>
<div>auditd_audispd_disk_full_action</div>
<h4>Description</h4>
<p>Configure the action the operating system takes if the disk the audit records
are written to becomes full. Edit the file <tt>/etc/audit/audisp-remote.conf</tt>.
Add or modify the following line, substituting <i>ACTION</i> appropriately:
<pre>disk_full_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single user
mode for corrective action. Acceptable values also include <tt>syslog</tt> and
<tt>halt</tt>. For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined.</p>
<h4>Rationale</h4>
<p>Taking appropriate action in case of a filled audit storage volume will
minimize the possibility of losing audit records.</p>
</div>

<div id="auditd_audispd_encrypt_sent_records" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Encrypt Audit Records Sent With audispd Plugin</h3>
<div>auditd_audispd_encrypt_sent_records</div>
<h4>Description</h4>
<p>Configure the operating system to encrypt the transfer of off-loaded audit
records onto a different system or media from the system being audited.

Uncomment the <tt>enable_krb5</tt> option in <pre>/etc/audit/audisp-remote.conf</pre>,
and set it with the following line:
<pre>enable_krb5 = yes</pre></p>
<h4>Rationale</h4>
<p>Information stored in one location is vulnerable to accidental or incidental deletion
or alteration. Off-loading is a common process in information systems with limited
audit storage capacity.</p>
</div>

<div id="auditd_audispd_network_failure_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure audispd's Plugin network_failure_action On Network Failure</h3>
<div>auditd_audispd_network_failure_action</div>
<h4>Description</h4>
<p>Configure the action the operating system takes if there is an error sending
audit records to a remote system. Edit the file <tt>/etc/audit/audisp-remote.conf</tt>.
Add or modify the following line, substituting <i>ACTION</i> appropriately:
<pre>network_failure_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single user
mode for corrective action. Acceptable values also include <tt>syslog</tt> and
<tt>halt</tt>. For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined.
This profile configures the <i>action</i> to be <tt><tt>$var_audispd_network_failure_action</tt></tt>.</p>
<h4>Rationale</h4>
<p>Taking appropriate action when there is an error sending audit records to a
remote system will minimize the possibility of losing audit records.</p>
</div>

<div id="auditd_audispd_remote_daemon_activated" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd to use audispd's remote logging daemon</h3>
<div>auditd_audispd_remote_daemon_activated</div>
<h4>Description</h4>
<p>To configure the <tt>auditd</tt> service to use the
<tt>audisp-remote</tt> plug-in of the <tt>audispd</tt> audit event multiplexor, set
the <tt>active</tt> directive in <tt>/etc/audit/plugins.d/au-remote.conf</tt>
to <tt>yes</tt>.
Restart the <tt>auditd</tt> service to apply configuration changes:
<pre>$ sudo service auditd restart</pre></p>
<h4>Rationale</h4>
<p>The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to a remote server.</p>
</div>

<div id="auditd_audispd_remote_daemon_direction" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the audispd's remote logging daemon direction is correct</h3>
<div>auditd_audispd_remote_daemon_direction</div>
<h4>Description</h4>
<p>Ensure the direction of logs in <tt>audisp-remote</tt>
plug-in of the <tt>audispd</tt> audit event multiplexor is correct.
Check that the <tt>direction</tt> directive in
<tt>/etc/audit/plugins.d/au-remote.conf</tt> is <tt>out</tt>.
Restart the <tt>auditd</tt> service to apply configuration changes:
<pre>$ sudo service auditd restart</pre></p>
<h4>Rationale</h4>
<p>The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to a remote server.

The direction is dictated by the plugin, and this parameter is used by the multiplexor
to understand the direction of events.</p>
</div>

<div id="auditd_audispd_remote_daemon_path" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the audispd's remote logging daemon executable is correct</h3>
<div>auditd_audispd_remote_daemon_path</div>
<h4>Description</h4>
<p>Ensure the executable used by <tt>audisp-remote</tt>
plug-in of the <tt>audispd</tt> audit event multiplexor is correct.
Check that the <tt>path</tt> directive in
<tt>/etc/audit/plugins.d/au-remote.conf</tt> is <tt>/sbin/audisp-remote</tt>.
Restart the <tt>auditd</tt> service to apply configuration changes:
<pre>$ sudo service auditd restart</pre></p>
<h4>Rationale</h4>
<p>The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to a remote server.</p>
</div>

<div id="auditd_audispd_remote_daemon_type" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the audispd's remote logging daemon type is correct</h3>
<div>auditd_audispd_remote_daemon_type</div>
<h4>Description</h4>
<p>Ensure the type used by <tt>audisp-remote</tt>
plug-in of the <tt>audispd</tt> audit event multiplexor is correct.
Check that the <tt>type</tt> directive in
<tt>/etc/audit/plugins.d/au-remote.conf</tt> is <tt>always</tt>.
Restart the <tt>auditd</tt> service to apply configuration changes:
<pre>$ sudo service auditd restart</pre></p>
<h4>Rationale</h4>
<p>The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to a remote server.</p>
</div>

<div id="auditd_audispd_syslog_plugin_activated" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd to use audispd's syslog plugin</h3>
<div>auditd_audispd_syslog_plugin_activated</div>
<h4>Description</h4>
<p>To configure the <tt>auditd</tt> service to use the
<tt>syslog</tt> plug-in of the <tt>audispd</tt> audit event multiplexor, set
the <tt>active</tt> line in <tt>/etc/audit/plugins.d/syslog.conf</tt> to <tt>yes</tt>.
Restart the <tt>auditd</tt> service:
<pre>$ sudo service auditd restart</pre></p>
<h4>Rationale</h4>
<p>The auditd service does not include the ability to send audit
records to a centralized server for management directly. It does, however,
include a plug-in for audit event multiplexor (audispd) to pass audit records
to the local syslog server.</p>
</div>

<div id="auditd_data_disk_error_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Disk Error Action on Disk Error</h3>
<div>auditd_data_disk_error_action</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when there is a disk error.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>disk_error_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single-user
mode for corrective action. Acceptable values also include

<tt>syslog</tt>, <tt>single</tt> and <tt>halt</tt>

For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined. Details regarding all possible values for <i>ACTION</i> are described in the
<tt>auditd.conf</tt> man page.</p>
<h4>Rationale</h4>
<p>Taking appropriate action in case of disk errors will minimize the possibility of
losing audit records.</p>
</div>

<div id="auditd_data_disk_error_action_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Disk Error Action on Disk Error</h3>
<div>auditd_data_disk_error_action_stig</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when there is a disk error.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>disk_error_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single-user
mode for corrective action. Acceptable values also include <tt>syslog</tt>,
<tt>exec</tt>, <tt>single</tt>, and <tt>halt</tt>. For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined. Details regarding all possible values for <i>ACTION</i> are described in the
<tt>auditd.conf</tt> man page.</p>
<h4>Rationale</h4>
<p>Taking appropriate action in case of disk errors will minimize the possibility of
losing audit records.</p>
</div>

<div id="auditd_data_disk_full_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Disk Full Action when Disk Space Is Full</h3>
<div>auditd_data_disk_full_action</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>disk_full_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single-user
mode for corrective action. Acceptable values also include

<tt>single</tt> and <tt>halt</tt>

For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined. Details regarding all possible values for <i>ACTION</i> are described in the
<tt>auditd.conf</tt> man page.</p>
<h4>Rationale</h4>
<p>Taking appropriate action in case of a filled audit storage volume will minimize
the possibility of losing audit records.</p>
</div>

<div id="auditd_data_disk_full_action_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Disk Full Action when Disk Space Is Full</h3>
<div>auditd_data_disk_full_action_stig</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>disk_full_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single-user
mode for corrective action. Acceptable values also include <tt>syslog</tt>,
<tt>single</tt>, and <tt>halt</tt>. For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined. Details regarding all possible values for <i>ACTION</i> are described in the
<tt>auditd.conf</tt> man page.</p>
<h4>Rationale</h4>
<p>Taking appropriate action in case of a filled audit storage volume will minimize
the possibility of losing audit records.</p>
</div>

<div id="auditd_data_retention_action_mail_acct" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd mail_acct Action on Low Disk Space</h3>
<div>auditd_data_retention_action_mail_acct</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to send email to
a designated account in certain situations. Add or correct the following line
in <tt>/etc/audit/auditd.conf</tt> to ensure that administrators are notified
via email for those situations:
<pre>action_mail_acct = <tt>$var_auditd_action_mail_acct</tt></pre></p>
<h4>Rationale</h4>
<p>Email sent to the root account is typically aliased to the
administrators of the system, who can take appropriate action.</p>
</div>

<div id="auditd_data_retention_admin_space_left_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd admin_space_left Action on Low Disk Space</h3>
<div>auditd_data_retention_admin_space_left_action</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>admin_space_left_action = <i>ACTION</i></pre>
Set this value to <tt>single</tt> to cause the system to switch to single user
mode for corrective action. Acceptable values also include <tt>suspend</tt> and
<tt>halt</tt>. For certain systems, the need for availability
outweighs the need to log all actions, and a different setting should be
determined. Details regarding all possible values for <i>ACTION</i> are described in the
<tt>auditd.conf</tt> man page.</p>
<h4>Rationale</h4>
<p>Administrators should be made aware of an inability to record
audit records. If a separate partition or logical volume of adequate size
is used, running low on space for audit records should never occur.</p>
</div>

<div id="auditd_data_retention_admin_space_left_percentage" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd admin_space_left on Low Disk Space</h3>
<div>auditd_data_retention_admin_space_left_percentage</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>PERCENTAGE</i> appropriately:
<pre>admin_space_left = <i>PERCENTAGE</i>%</pre>
Set this value to <tt>$var_auditd_admin_space_left_percentage</tt>
to cause the system to perform an action.</p>
<h4>Rationale</h4>
<p>Notifying administrators of an impending disk space problem may allow them to
take corrective action prior to any disruption.</p>
</div>

<div id="auditd_data_retention_flush" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd flush priority</h3>
<div>auditd_data_retention_flush</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to
synchronously write audit event data to disk. Add or correct the following
line in <tt>/etc/audit/auditd.conf</tt> to ensure that audit event data is
fully synchronized with the log files on the disk:
<pre>flush = <tt>$var_auditd_flush</tt></pre></p>
<h4>Rationale</h4>
<p>Audit data should be synchronously written to disk to ensure
log integrity. These parameters assure that all audit event data is fully
synchronized with the log files on the disk.</p>
</div>

<div id="auditd_data_retention_max_log_file" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Max Log File Size</h3>
<div>auditd_data_retention_max_log_file</div>
<h4>Description</h4>
<p>Determine the amount of audit data (in megabytes)
which should be retained in each log file. Edit the file
<tt>/etc/audit/auditd.conf</tt>. Add or modify the following line, substituting
the correct value of <tt>$var_auditd_max_log_file</tt> for <i>STOREMB</i>:
<pre>max_log_file = <i>STOREMB</i></pre>
Set the value to <tt>6</tt> (MB) or higher for general-purpose systems.
Larger values, of course,
support retention of even more audit data.</p>
<h4>Rationale</h4>
<p>The total storage for audit log files must be large enough to retain
log information over the period required. This is a function of the maximum
log file size and the number of logs retained.</p>
</div>

<div id="auditd_data_retention_max_log_file_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd max_log_file_action Upon Reaching Maximum Log Size</h3>
<div>auditd_data_retention_max_log_file_action</div>
<h4>Description</h4>
<p>The default action to take when the logs reach their maximum size
is to rotate the log files, discarding the oldest one. To configure the action taken
by <tt>auditd</tt>, add or correct the line in <tt>/etc/audit/auditd.conf</tt>:
<pre>max_log_file_action = <i>ACTION</i></pre>
Possible values for <i>ACTION</i> are described in the <tt>auditd.conf</tt> man
page. These include:
<ul>
<li><tt>ignore</tt></li>
<li><tt>syslog</tt></li>
<li><tt>suspend</tt></li>
<li><tt>rotate</tt></li>
<li><tt>keep_logs</tt></li>
</ul>
Set the <tt><i>ACTION</i></tt> to <tt><tt>$var_auditd_max_log_file_action</tt></tt>.
The setting is case-insensitive.</p>
<h4>Rationale</h4>
<p>Automatically rotating logs (by setting this to <tt>rotate</tt>)
minimizes the chances of the system unexpectedly running out of disk space by
being overwhelmed with log data. However, for systems that must never discard
log data, or which use external processes to transfer it and reclaim space,
<tt>keep_logs</tt> can be employed.</p>
</div>

<div id="auditd_data_retention_max_log_file_action_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd max_log_file_action Upon Reaching Maximum Log Size</h3>
<div>auditd_data_retention_max_log_file_action_stig</div>
<h4>Description</h4>
<p>The default action to take when the logs reach their maximum size
is to rotate the log files, discarding the oldest one. To configure the action taken
by <tt>auditd</tt>, add or correct the line in <tt>/etc/audit/auditd.conf</tt>:
<pre>max_log_file_action = <i>ACTION</i></pre>
Possible values for <i>ACTION</i> are described in the <tt>auditd.conf</tt> man
page. These include:
<ul>
<li><tt>ignore</tt></li>
<li><tt>syslog</tt></li>
<li><tt>suspend</tt></li>
<li><tt>rotate</tt></li>
<li><tt>keep_logs</tt></li>
</ul>
Set the <tt><i>ACTION</i></tt> to <tt>rotate</tt> to ensure log rotation
occurs. This is the default. The setting is case-insensitive.</p>
<h4>Rationale</h4>
<p>Automatically rotating logs (by setting this to <tt>rotate</tt>)
minimizes the chances of the system unexpectedly running out of disk space by
being overwhelmed with log data. However, for systems that must never discard
log data, or which use external processes to transfer it and reclaim space,
<tt>keep_logs</tt> can be employed.</p>
</div>

<div id="auditd_data_retention_num_logs" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd Number of Logs Retained</h3>
<div>auditd_data_retention_num_logs</div>
<h4>Description</h4>
<p>Determine how many log files
<tt>auditd</tt> should retain when it rotates logs.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following
line, substituting <i>NUMLOGS</i> with the correct value of <tt>$var_auditd_num_logs</tt>:
<pre>num_logs = <i>NUMLOGS</i></pre>
Set the value to 5 for general-purpose systems.
Note that values less than 2 result in no log rotation.</p>
<h4>Rationale</h4>
<p>The total storage for audit log files must be large enough to retain
log information over the period required. This is a function of the maximum log
file size and the number of logs retained.</p>
</div>

<div id="auditd_data_retention_space_left" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd space_left on Low Disk Space</h3>
<div>auditd_data_retention_space_left</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>SIZE_in_MB</i> appropriately:
<pre>space_left = <i>SIZE_in_MB</i></pre>
Set this value to the appropriate size in Megabytes cause the system to
notify the user of an issue.</p>
<h4>Rationale</h4>
<p>Notifying administrators of an impending disk space problem may allow them to
take corrective action prior to any disruption.</p>
</div>

<div id="auditd_data_retention_space_left_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd space_left Action on Low Disk Space</h3>
<div>auditd_data_retention_space_left_action</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space <i>starts</i> to run low.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Modify the following line,
substituting <i>ACTION</i> appropriately:
<pre>space_left_action = <i>ACTION</i></pre>
Possible values for <i>ACTION</i> are described in the <tt>auditd.conf</tt> man page.
These include:
<ul>
<li><tt>syslog</tt></li>
<li><tt>email</tt></li>
<li><tt>exec</tt></li>
<li><tt>suspend</tt></li>
<li><tt>single</tt></li>
<li><tt>halt</tt></li>
</ul>
Set this to <tt>email</tt> (instead of the default,
which is <tt>suspend</tt>) as it is more likely to get prompt attention. Acceptable values
also include <tt>suspend</tt>, <tt>single</tt>, and <tt>halt</tt>.</p>
<h4>Rationale</h4>
<p>Notifying administrators of an impending disk space problem may
allow them to take corrective action prior to any disruption.</p>
</div>

<div id="auditd_data_retention_space_left_percentage" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Configure auditd space_left on Low Disk Space</h3>
<div>auditd_data_retention_space_left_percentage</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service can be configured to take an action
when disk space is running low but prior to running out of space completely.
Edit the file <tt>/etc/audit/auditd.conf</tt>. Add or modify the following line,
substituting <i>PERCENTAGE</i> appropriately:
<pre>space_left = <i>PERCENTAGE</i>%</pre>
Set this value to at least 25 to cause the system to
notify the user of an issue.</p>
<h4>Rationale</h4>
<p>Notifying administrators of an impending disk space problem may allow them to
take corrective action prior to any disruption.</p>
</div>

<div id="auditd_freq" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Set number of records to cause an explicit flush to audit logs</h3>
<div>auditd_freq</div>
<h4>Description</h4>
<p>To configure Audit daemon to issue an explicit flush to disk command
after writing <tt>$var_auditd_freq</tt> records, set <tt>freq</tt> to <tt><tt>$var_auditd_freq</tt></tt>
in <tt>/etc/audit/auditd.conf</tt>.</p>
<h4>Rationale</h4>
<p>If option <tt>freq</tt> isn't set to <tt><tt>$var_auditd_freq</tt></tt>, the flush to disk
may happen after higher number of records, increasing the danger
of audit loss.</p>
</div>

<div id="auditd_local_events" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Include Local Events in Audit Logs</h3>
<div>auditd_local_events</div>
<h4>Description</h4>
<p>To configure Audit daemon to include local events in Audit logs, set
<tt>local_events</tt> to <tt>yes</tt> in <tt>/etc/audit/auditd.conf</tt>.
This is the default setting.</p>
<h4>Rationale</h4>
<p>If option <tt>local_events</tt> isn't set to <tt>yes</tt> only events from
network will be aggregated.</p>
</div>

<div id="auditd_log_format" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Resolve information before writing to audit logs</h3>
<div>auditd_log_format</div>
<h4>Description</h4>
<p>To configure Audit daemon to resolve all uid, gid, syscall,
architecture, and socket address information before writing the
events to disk, set <tt>log_format</tt> to <tt>ENRICHED</tt>
in <tt>/etc/audit/auditd.conf</tt>.</p>
<h4>Rationale</h4>
<p>If option <tt>log_format</tt> isn't set to <tt>ENRICHED</tt>, the
audit records will be stored in a format exactly as the kernel sends them.</p>
</div>

<div id="auditd_name_format" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Set type of computer node name logging in audit logs</h3>
<div>auditd_name_format</div>
<h4>Description</h4>
<p>To configure Audit daemon to use a unique identifier
as computer node name in the audit events,
set <tt>name_format</tt> to <tt><tt>$var_auditd_name_format</tt></tt>
in <tt>/etc/audit/auditd.conf</tt>.</p>
<h4>Rationale</h4>
<p>If option <tt>name_format</tt> is left at its default value of
<tt>none</tt>, audit events from different computers may be hard
to distinguish.</p>
</div>

<div id="auditd_offload_logs" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Offload audit Logs to External Media</h3>
<div>auditd_offload_logs</div>
<h4>Description</h4>
<p>The operating system must have a crontab script running weekly to
offload audit events of standalone systems.</p>
<h4>Rationale</h4>
<p>Information stored in one location is vulnerable to accidental or
incidental deletion or alteration.
Offloading is a common process in information systems with limited
audit storage capacity.</p>
</div>

<div id="auditd_overflow_action" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Appropriate Action Must be Setup When the Internal Audit Event Queue is Full</h3>
<div>auditd_overflow_action</div>
<h4>Description</h4>
<p>The audit system should have an action setup in the event the internal event queue becomes full.
To setup an overflow action edit <tt>/etc/audit/auditd.conf</tt>. Set <tt>overflow_action</tt>
to one of the following values: <tt>syslog</tt>, <tt>single</tt>, <tt>halt</tt>.</p>
<h4>Rationale</h4>
<p>The audit system should have an action setup in the event the internal event queue becomes full
so that no data is lost.</p>
</div>

<div id="auditd_write_logs" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Write Audit Logs to the Disk</h3>
<div>auditd_write_logs</div>
<h4>Description</h4>
<p>To configure Audit daemon to write Audit logs to the disk, set
<tt>write_logs</tt> to <tt>yes</tt> in <tt>/etc/audit/auditd.conf</tt>.
This is the default setting.</p>
<h4>Rationale</h4>
<p>If <tt>write_logs</tt> isn't set to <tt>yes</tt>, the Audit logs will
not be written to the disk.</p>
</div>

<div id="coreos_audit_backlog_limit_kernel_argument" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Extend Audit Backlog Limit for the Audit Daemon</h3>
<div>coreos_audit_backlog_limit_kernel_argument</div>
<h4>Description</h4>
<p>To improve the kernel capacity to queue all log events, even those which occurred
prior to the audit daemon, add the argument <tt>audit_backlog_limit=8192</tt> to all
BLS (Boot Loader Specification) entries ('options' line) for the Linux
operating system in <tt>/boot/loader/entries/*.conf</tt>.</p>
<h4>Rationale</h4>
<p>audit_backlog_limit sets the queue length for audit events awaiting transfer
to the audit daemon. Until the audit daemon is up and running, all log messages
are stored in this queue.  If the queue is overrun during boot process, the action
defined by audit failure flag is taken.</p>
</div>

<div id="coreos_audit_option" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Enable Auditing for Processes Which Start Prior to the Audit Daemon</h3>
<div>coreos_audit_option</div>
<h4>Description</h4>
<p>To ensure all processes can be audited, even those which start
prior to the audit daemon, add the argument <tt>audit=1</tt> to all
BLS (Boot Loader Specification) entries ('options' line) for the Linux
operating system in <tt>/boot/loader/entries/*.conf</tt>.</p>
<h4>Rationale</h4>
<p>Each process on the system carries an "auditable" flag which indicates whether
its activities can be audited. Although <tt>auditd</tt> takes care of enabling
this for all processes which launch after it does, adding the kernel argument
ensures it is set for every process during boot.</p>
</div>

<div id="directory_access_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Record Access Events to Audit Log Directory</h3>
<div>directory_access_var_log_audit</div>
<h4>Description</h4>
<p>The audit system should collect access events to read audit log directory.
The following audit rule will assure that access to audit log directory are
collected.
Set ARCH to either b32 for 32-bit system, or have two lines for both b32 and b64 in case your system is 64-bit.
<pre>-a always,exit -F arch=ARCH -F dir=/var/log/audit/ -F perm=r -F auid>=1000 -F auid!=unset -F key=access-audit-trail</pre>
If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
rule to a file with suffix <tt>.rules</tt> in the directory
<tt>/etc/audit/rules.d</tt>.
If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the rule to
<tt>/etc/audit/audit.rules</tt> file.</p>
<h4>Rationale</h4>
<p>Attempts to read the logs should be recorded, suspicious access to audit log files could be an indicator of malicious activity on a system.
Auditing these events could serve as evidence of potential system compromise.'</p>
</div>

<div id="directory_group_ownership_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Directories Must Be Group Owned By Root</h3>
<div>directory_group_ownership_var_log_audit</div>
<h4>Description</h4>
<p>All audit directories must be group owned by root user. By default, the path for audit log is <pre>/var/log/audit/</pre>.

To properly set the group owner of <code>/var/log/audit</code>, run the command:

  <pre>$ sudo chgrp root /var/log/audit</pre>
  


If <tt>log_group</tt> in <tt>/etc/audit/auditd.conf</tt> is set to a group other than the <tt>root</tt>
group account, change the group ownership of the audit directories to this specific group.</p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="directory_ownership_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Directories Must Be Owned By Root</h3>
<div>directory_ownership_var_log_audit</div>
<h4>Description</h4>
<p>All audit directories must be owned by root user. By default, the path for audit log is <pre>/var/log/audit/</pre>.

To properly set the owner of <code>/var/log/audit</code>, run the command:

  <pre>$ sudo chown root /var/log/audit </pre>
  </p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="directory_permissions_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Have Mode 0750 or Less Permissive</h3>
<div>directory_permissions_var_log_audit</div>
<h4>Description</h4>
<p>
If <tt>log_group</tt> in <tt>/etc/audit/auditd.conf</tt> is set to a group other than the <tt>root</tt>
group account, change the mode of the audit log files with the following command:
<pre>$ sudo chmod 0750 /var/log/audit</pre>
<br />
Otherwise, change the mode of the audit log files with the following command:
<pre>$ sudo chmod 0700 /var/log/audit</pre></p>
<h4>Rationale</h4>
<p>If users can write to audit logs, audit trails can be modified or destroyed.</p>
</div>

<div id="file_group_ownership_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Be Group Owned By Root</h3>
<div>file_group_ownership_var_log_audit</div>
<h4>Description</h4>
<p>All audit logs must be group owned by root user. The path for audit log can
be configured via <tt>log_file</tt> parameter in <pre>/etc/audit/auditd.conf</pre>
or, by default, the path for audit log is <pre>/var/log/audit/</pre>.

To properly set the group owner of <code>/var/log/audit/*</code>, run the command:

  <pre>$ sudo chgrp root /var/log/audit/*</pre>
  


If <tt>log_group</tt> in <tt>/etc/audit/auditd.conf</tt> is set to a group other
than the <tt>root</tt> group account, change the group ownership of the audit logs
to this specific group.</p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="file_group_ownership_var_log_audit_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Be Group Owned By Root</h3>
<div>file_group_ownership_var_log_audit_stig</div>
<h4>Description</h4>
<p>All audit logs must be group owned by root user.

Determine where the audit logs are stored with the following command:
<pre>$ sudo grep -iw log_file /etc/audit/auditd.conf
log_file = /var/log/audit/audit.log</pre>

Using the path of the directory containing the audit logs, determine if the audit log files
are owned by the "root" group by using the following command:
<pre>$ sudo stat -c "%n %G" /var/log/audit/*
/var/log/audit/audit.log root</pre>
If the audit log files are owned by a group other than "root", this is a finding.

To remediate, configure the audit log directory and its underlying files to be owned by "root"
group.

Set the "log_group" parameter of the audit configuration file to the "root" value so when a
new log file is created, its group owner is properly set:
<pre>$ sudo sed -i '/^log_group/D' /etc/audit/auditd.conf
$ sudo sed -i /^log_file/a'log_group = root' /etc/audit/auditd.conf</pre>

Last, signal the audit daemon to reload the configuration file to update the group owners
of existing files:
<pre>$ sudo systemctl kill auditd -s SIGHUP</pre></p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="file_groupownership_audit_configuration" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Audit Configuration Files Must Be Owned By Group root</h3>
<div>file_groupownership_audit_configuration</div>
<h4>Description</h4>
<p>All audit configuration files must be owned by group root.
<pre>chown :root /etc/audit/audit*.{rules,conf} /etc/audit/rules.d/*</pre></p>
<h4>Rationale</h4>
<p>Without the capability to restrict which roles and individuals can
select which events are audited, unauthorized personnel may be able
to prevent the auditing of critical events.
Misconfigured audits may degrade the system's performance by
overwhelming the audit log. Misconfigured audits may also make it more
difficult to establish, correlate, and investigate the events relating
to an incident or identify those responsible for one.</p>
</div>

<div id="file_ownership_audit_configuration" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Audit Configuration Files Must Be Owned By Root</h3>
<div>file_ownership_audit_configuration</div>
<h4>Description</h4>
<p>All audit configuration files must be owned by root user.

To properly set the owner of <code>/etc/audit/</code>, run the command:

  <pre>$ sudo chown root /etc/audit/ </pre>
  


To properly set the owner of <code>/etc/audit/rules.d/</code>, run the command:

  <pre>$ sudo chown root /etc/audit/rules.d/ </pre>
  </p>
<h4>Rationale</h4>
<p>Without the capability to restrict which roles and individuals can
select which events are audited, unauthorized personnel may be able
to prevent the auditing of critical events.
Misconfigured audits may degrade the system's performance by
overwhelming the audit log. Misconfigured audits may also make it more
difficult to establish, correlate, and investigate the events relating
to an incident or identify those responsible for one.</p>
</div>

<div id="file_ownership_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Be Owned By Root</h3>
<div>file_ownership_var_log_audit</div>
<h4>Description</h4>
<p>All audit logs must be owned by root user and group. By default, the path for audit log is <pre>/var/log/audit/</pre>.

To properly set the owner of <code>/var/log/audit</code>, run the command:

  <pre>$ sudo chown root /var/log/audit </pre>
  


To properly set the owner of <code>/var/log/audit/*</code>, run the command:

  <pre>$ sudo chown root /var/log/audit/* </pre>
  </p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="file_ownership_var_log_audit_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Be Owned By Root</h3>
<div>file_ownership_var_log_audit_stig</div>
<h4>Description</h4>
<p>All audit logs must be owned by root user. The path for audit log can be
configured via <tt>log_file</tt> parameter in <pre>/etc/audit/auditd.conf</pre>
or by default, the path for audit log is <pre>/var/log/audit/</pre>.

To properly set the owner of <code>/var/log/audit/*</code>, run the command:

  <pre>$ sudo chown root /var/log/audit/* </pre>
  </p>
<h4>Rationale</h4>
<p>Unauthorized disclosure of audit records can reveal system and configuration data to
attackers, thus compromising its confidentiality.</p>
</div>

<div id="file_permissions_audit_configuration" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Audit Configuration Files Permissions are 640 or More Restrictive</h3>
<div>file_permissions_audit_configuration</div>
<h4>Description</h4>
<p>All audit configuration files permissions must be 640 or more restrictive.
<pre>chmod 0640 /etc/audit/audit*.{rules,conf} /etc/audit/rules.d/*</pre></p>
<h4>Rationale</h4>
<p>Without the capability to restrict which roles and individuals can
select which events are audited, unauthorized personnel may be able
to prevent the auditing of critical events.
Misconfigured audits may degrade the system's performance by
overwhelming the audit log. Misconfigured audits may also make it more
difficult to establish, correlate, and investigate the events relating
to an incident or identify those responsible for one.</p>
</div>

<div id="file_permissions_etc_audit_auditd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Verify Permissions on /etc/audit/auditd.conf</h3>
<div>file_permissions_etc_audit_auditd</div>
<h4>Description</h4>
<p>
To properly set the permissions of <code>/etc/audit/auditd.conf</code>, run the command:
<pre>$ sudo chmod 0640 /etc/audit/auditd.conf</pre></p>
<h4>Rationale</h4>
<p>Without the capability to restrict the roles and individuals that can select which events
are audited, unauthorized personnel may be able to prevent the auditing of critical
events. Misconfigured audits may degrade the system's performance by overwhelming
the audit log. Misconfigured audits may also make it more difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.</p>
</div>

<div id="file_permissions_etc_audit_rulesd" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Verify Permissions on /etc/audit/rules.d/*.rules</h3>
<div>file_permissions_etc_audit_rulesd</div>
<h4>Description</h4>
<p>
To properly set the permissions of <code>/etc/audit/rules.d/*.rules</code>, run the command:
<pre>$ sudo chmod 0600 /etc/audit/rules.d/*.rules</pre></p>
<h4>Rationale</h4>
<p>Without the capability to restrict the roles and individuals that can select which events
are audited, unauthorized personnel may be able to prevent the auditing of critical
events. Misconfigured audits may degrade the system's performance by overwhelming
the audit log. Misconfigured audits may also make it more difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.</p>
</div>

<div id="file_permissions_etc_audit_rules" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Verify Permissions on /etc/audit/audit.rules</h3>
<div>file_permissions_etc_audit_rules</div>
<h4>Description</h4>
<p>
To properly set the permissions of <code>/etc/audit/audit.rules</code>, run the command:
<pre>$ sudo chmod 0640 /etc/audit/audit.rules</pre></p>
<h4>Rationale</h4>
<p>Without the capability to restrict the roles and individuals that can select which events
are audited, unauthorized personnel may be able to prevent the auditing of critical
events. Misconfigured audits may degrade the system's performance by overwhelming
the audit log. Misconfigured audits may also make it more difficult to establish,
correlate, and investigate the events relating to an incident or identify
those responsible for one.</p>
</div>

<div id="file_permissions_var_log_audit" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Have Mode 0640 or Less Permissive</h3>
<div>file_permissions_var_log_audit</div>
<h4>Description</h4>
<p>
If <tt>log_group</tt> in <tt>/etc/audit/auditd.conf</tt> is set to a group other than the
<tt>root</tt>
group account, change the mode of the audit log files with the following command:
<pre>$ sudo chmod 0640 <i>audit_file</i></pre>
<br />
Otherwise, change the mode of the audit log files with the following command:
<pre>$ sudo chmod 0600 <i>audit_file</i></pre></p>
<h4>Rationale</h4>
<p>If users can write to audit logs, audit trails can be modified or destroyed.</p>
</div>

<div id="file_permissions_var_log_audit_stig" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>System Audit Logs Must Have Mode 0600 or Less Permissive</h3>
<div>file_permissions_var_log_audit_stig</div>
<h4>Description</h4>
<p>Determine where the audit logs are stored with the following command:
<pre>$ sudo grep -iw log_file /etc/audit/auditd.conf
log_file = /var/log/audit/audit.log</pre>

Using the path of the directory containing the audit logs, determine
if the audit log files have a mode of "600" or less by using the following command:
<pre>$ sudo stat -c "%n %a" /var/log/audit/*</pre></p>
<h4>Rationale</h4>
<p>If users can write to audit logs, audit trails can be modified or destroyed.</p>
</div>

<div id="grub2_audit_argument" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Enable Auditing for Processes Which Start Prior to the Audit Daemon</h3>
<div>grub2_audit_argument</div>
<h4>Description</h4>
<p>To ensure all processes can be audited, even those which start
prior to the audit daemon, add the argument <tt>audit=1</tt> to the default
GRUB 2 command line for the Linux operating system.
To ensure that <tt>audit=1</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>audit=1</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... audit=1 ..."</pre>
Run the following command to update command line for already installed kernels:<pre># update-grub</pre></p>
<h4>Rationale</h4>
<p>Each process on the system carries an "auditable" flag which indicates whether
its activities can be audited. Although <tt>auditd</tt> takes care of enabling
this for all processes which launch after it does, adding the kernel argument
ensures it is set for every process during boot.</p>
</div>

<div id="grub2_audit_backlog_limit_argument" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Extend Audit Backlog Limit for the Audit Daemon</h3>
<div>grub2_audit_backlog_limit_argument</div>
<h4>Description</h4>
<p>To improve the kernel capacity to queue all log events, even those which occurred
prior to the audit daemon, add the argument <tt>audit_backlog_limit=8192</tt> to the default
GRUB 2 command line for the Linux operating system.
To ensure that <tt>audit_backlog_limit=8192</tt> is added as a kernel command line
argument to newly installed kernels, add <tt>audit_backlog_limit=8192</tt> to the
default Grub2 command line for Linux operating systems. Modify the line within
<tt>/etc/default/grub</tt> as shown below:
<pre>GRUB_CMDLINE_LINUX="... audit_backlog_limit=8192 ..."</pre>
Run the following command to update command line for already installed kernels:<pre># update-grub</pre></p>
<h4>Rationale</h4>
<p>audit_backlog_limit sets the queue length for audit events awaiting transfer
to the audit daemon. Until the audit daemon is up and running, all log messages
are stored in this queue.  If the queue is overrun during boot process, the action
defined by audit failure flag is taken.</p>
</div>

<div id="package_audispd-plugins_installed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Install audispd-plugins Package</h3>
<div>package_audispd-plugins_installed</div>
<h4>Description</h4>
<p>The <code>audispd-plugins</code> package can be installed with the following command:
<pre>
$ apt-get install audispd-plugins</pre></p>
<h4>Rationale</h4>
<p><tt>audispd-plugins</tt> provides plugins for the real-time interface to the
audit subsystem, <tt>audispd</tt>. These plugins can do things like relay events
to remote machines or analyze events for suspicious behavior.</p>
</div>

<div id="package_audit-audispd-plugins_installed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the default plugins for the audit dispatcher are Installed</h3>
<div>package_audit-audispd-plugins_installed</div>
<h4>Description</h4>
<p>The audit-audispd-plugins package should be installed.</p>
<h4>Rationale</h4>
<p>Information stored in one location is vulnerable to accidental or incidental deletion or alteration. Off-loading is a common process in information systems with limited audit storage capacity.</p>
</div>

<div id="package_audit-libs_installed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the audit-libs package as a part of audit Subsystem is Installed</h3>
<div>package_audit-libs_installed</div>
<h4>Description</h4>
<p>The audit-libs package should be installed.</p>
<h4>Rationale</h4>
<p>The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.</p>
</div>

<div id="package_audit_installed" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure the audit Subsystem is Installed</h3>
<div>package_audit_installed</div>
<h4>Description</h4>
<p>The audit package should be installed.</p>
<h4>Rationale</h4>
<p>The auditd service is an access monitoring and accounting daemon, watching system calls to audit any access, in comparison with potential local access control policy such as SELinux policy.</p>
</div>

<div id="service_auditd_enabled" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Enable auditd Service</h3>
<div>service_auditd_enabled</div>
<h4>Description</h4>
<p>The <tt>auditd</tt> service is an essential userspace component of
the Linux Auditing System, as it is responsible for writing audit records to
disk.

The <code>auditd</code> service can be enabled with the following command:
<pre>$ sudo systemctl enable auditd.service</pre></p>
<h4>Rationale</h4>
<p>Without establishing what type of events occurred, it would be difficult
to establish, correlate, and investigate the events leading up to an outage or attack.
Ensuring the <tt>auditd</tt> service is active ensures audit records
generated by the kernel are appropriately recorded.
<br /><br />
Additionally, a properly configured audit subsystem ensures that actions of
individual system users can be uniquely traced to those users so they
can be held accountable for their actions.</p>
</div>

<div id="audit_rules_etc_cron_d" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Changes to Cron Jobs - /etc/cron.d/</h3>
<div>audit_rules_etc_cron_d</div>
<h4>Description</h4>
<p>At a minimum, the audit system should collect administrator actions
for all users and root.




If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /etc/cron.d/ -p wa -k cronjobs</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /etc/cron.d/ -p wa -k cronjobs</pre></p>
<h4>Rationale</h4>
<p>The actions taken by system administrators should be audited to keep a record
of what was executed on the system, as well as, for accountability purposes.
Editing the sudoers file may be sign of an attacker trying to
establish persistent methods to a system, auditing the editing of the sudoers
files mitigates this risk.</p>
</div>

<div id="audit_rules_var_spool_cron" class="rule" style="border-bottom: 2px solid; margin-bottom: 1cm; padding-bottom: 1cm;">
<h3>Ensure auditd Collects Changes to Cron Jobs - /var/spool/cron</h3>
<div>audit_rules_var_spool_cron</div>
<h4>Description</h4>
<p>



If the <tt>auditd</tt> daemon is configured to use the <tt>augenrules</tt>
program to read audit rules during daemon startup (the default), add the
following lines to a file with suffix <tt>.rules</tt> in the
directory <tt>/etc/audit/rules.d</tt>:

<pre>-w /var/spool/cron -p wa -k cronjobs</pre>

If the <tt>auditd</tt> daemon is configured to use the <tt>auditctl</tt>
utility to read audit rules during daemon startup, add the following lines to
<tt>/etc/audit/audit.rules</tt>:

<pre>-w /var/spool/cron -p wa -k cronjobs</pre></p>
<h4>Rationale</h4>
<p>In addition to auditing new user and group accounts, these watches
will alert the system administrator(s) to any modifications. Any unexpected
users, groups, or modifications should be investigated for legitimacy.</p>
</div>




</body>
</html>